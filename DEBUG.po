# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2018-02-22 15:55+0900\n"
"PO-Revision-Date: 2018-02-24 00:05+0900\n"
"Last-Translator: Ayanokoji Takesi <ayanokoji.takesi@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: DEBUG.orig:2
msgid "Debugging GNU Emacs"
msgstr "GNU Emacsのデバッグ"

#. type: Plain text
#: DEBUG.orig:5
msgid ""
"Copyright (C) 1985, 2000-2017 Free Software Foundation, Inc.  See the end of "
"the file for license conditions."
msgstr "Copyright (C) 1985, 2000-2017 Free Software Foundation, Inc.  See the end of the file for license conditions."

#. type: Plain text
#: DEBUG.orig:7
#, no-wrap
msgid "** Preliminaries\n"
msgstr "** 前置き\n"

#. type: Plain text
#: DEBUG.orig:11
msgid ""
"This section can be skipped if you are already familiar with building Emacs "
"with debug info, configuring and starting GDB, and simple GDB debugging "
"techniques."
msgstr "このセクションは、あなたがすでにdebug情報つきEmacsのビルドや、GDBの設定と開始、GDBによる簡単なデバッグテクニックに親しんでいる場合はスキップできます。"

#. type: Plain text
#: DEBUG.orig:13
#, no-wrap
msgid "*** Configuring Emacs for debugging\n"
msgstr "*** デバッグ用Emacsのconfigure\n"

#. type: Plain text
#: DEBUG.orig:18
msgid ""
"It is best to configure and build Emacs with special options that will make "
"the debugging easier.  Here's the configure-time options we recommend (they "
"are in addition to any other options you might need, such as --prefix):"
msgstr "デバッグを簡単にするには、特別なオプションでEmacsをconfigureしてビルドするのが最善です。以下はわたしたちが推奨するconfigure時のオプションです(これらのオプションは、--prefixのようなあなたが必要とするかもしれない他のオプションに追加します)。"

#. type: Plain text
#: DEBUG.orig:20
#, no-wrap
msgid ""
"  CFLAGS='-O0 -g3' ./configure --enable-checking='yes,glyphs' "
"--enable-check-lisp-object-type\n"
msgstr "  CFLAGS='-O0 -g3' ./configure --enable-checking='yes,glyphs' --enable-check-lisp-object-type\n"

#. type: Plain text
#: DEBUG.orig:26
msgid ""
"The CFLAGS value is important: debugging optimized code can be very hard.  "
"(If the problem only happens with optimized code, you may need to enable "
"optimizations.  If that happens, try using -Og first, instead of -O2, as the "
"former will disable some optimizations that make debugging some code "
"exceptionally hard.)"
msgstr "CFLAGSの値は重要です。なぜなら最適化されたコードのデバッグはとても困難だからです。(最適化されたコードでのみ問題が発生する場合は、最適化を有効にする必要があるかもしれません。このような場合は-O2のかわりにまず-Ogの使用を試みてください。-Ogはある種のコードのデバッグを極めて困難にするいくつかの最適化を無効にします。)"

#. type: Plain text
#: DEBUG.orig:32
msgid ""
"Modern versions of GCC support more elaborate debug info that is available "
"by just using the -g3 compiler switch.  Try using -gdwarf-4 in addition to "
"-g3, and if that fails, try -gdwarf-3.  This is especially important if you "
"have to debug optimized code.  More info about this is available below; "
"search for \"analyze failed assertions\"."
msgstr "GCCのモダンなバージョンはコンパイラースイッチに-g3を使用するだけで利用できる、より精緻なdebug情報をサポートします。-g3に加えて-gdwarf-4を、それが失敗するようなら-gdwarf-3を試してみてください。これは最適化されたコードをデバッグする必要がある場合、とても重要になります。これに関する追加情報は以下の\"analyze failed assertionsの検索\"にあります。"

#. type: Plain text
#: DEBUG.orig:39
msgid ""
"The 2 --enable-* switches are optional.  They don't have any effect on "
"debugging with GDB, but will compile additional code that might catch the "
"problem you are debugging much earlier, in the form of assertion violation.  "
"The --enable-checking option also enables additional functionality useful "
"for debugging display problems; see more about this below under \"Debugging "
"Emacs redisplay problems\"."
msgstr "2つの--enable-*スイッチはオプションです。これらはGDBによるデバッグに影響を与えませんが、デバッグしている問題をより早くcatchするかもしれない追加コードをassertion violation形式でコンパイルします。--enable-checkingオプションは表示に関する問題をデバッグするのに有用な追加機能も有効にします。詳細は、以下の\"Emacsの再表示に関する問題のデバッグ\"を参照してください。"

#. type: Plain text
#: DEBUG.orig:42
msgid ""
"Emacs needs not be installed to be debugged, you can debug the binary "
"created in the 'src' directory."
msgstr "デバッグ用のEmacsをインストールする必要はありません。'src'ディレクトリーに作成されるバイナリーをデバッグできます。"

#. type: Plain text
#: DEBUG.orig:44
#, no-wrap
msgid "*** Configuring GDB\n"
msgstr "*** GDBの設定\n"

#. type: Plain text
#: DEBUG.orig:51
msgid ""
"When you debug Emacs with GDB, you should start GDB in the directory where "
"the Emacs executable was made (the 'src' directory in the Emacs source "
"tree).  That directory has a .gdbinit file that defines various "
"\"user-defined\" commands for debugging Emacs.  (These commands are "
"described below under \"Examining Lisp object values\" and \"Debugging Emacs "
"Redisplay problems\".)"
msgstr "GDBでEmacをデバッグするときは、Emacs実行形式が作成されたディレクトリー(Emacsソースツリー内の'src'ディレクトリー)から直接GDBを開始するべきです。このディレクトリーには、Emacsをデバッグするためのさまざまなユーザー定義コマンドを定義する、.gdbinitファイルがあります(これらのコマンドは以下の\"Lispオブジェクトの値の調査\"および\"Emacsの再表示に関する問題のデバッグ\"で説明されています)。"

#. type: Plain text
#: DEBUG.orig:55
msgid ""
"Starting the debugger from Emacs, via the \"M-x gdb\" command (described "
"below), when the current buffer visits one of the Emacs C source files will "
"automatically start GDB in the 'src' directory."
msgstr "カレントバッファーでEmacsのCソースファイルのどれか1つをvisitしているときに、Emacsから\"M-x gdb\"コマンド(以下参照)によりデバッガーを開始すると、'src'ディレクトリー内で自動的にGDBが開始されます。"

#. type: Plain text
#: DEBUG.orig:59
msgid ""
"Some GDB versions by default do not automatically load .gdbinit files in the "
"directory where you invoke GDB.  With those versions of GDB, you will see a "
"warning when GDB starts, like this:"
msgstr "GDBのいくつかのバージョンでは、デフォルトではGDBを呼び出したディレクトリー内の.gdbinitファイルを自動的にロードしません。このようなバージョンのGDBでは、GDBを開始したとき以下のような警告を目にするかもしれません:"

#. type: Plain text
#: DEBUG.orig:61
#, no-wrap
msgid ""
"  warning: File \".../src/.gdbinit\" auto-loading has been declined by your "
"`auto-load safe-path' set to \"$debugdir:$datadir/auto-load\".\n"
msgstr "  warning: File \".../src/.gdbinit\" auto-loading has been declined by your `auto-load safe-path' set to \"$debugdir:$datadir/auto-load\".\n"

#. type: Plain text
#: DEBUG.orig:64
msgid ""
"The simplest way to fix this is to add the following line to your ~/.gdbinit "
"file:"
msgstr "これを修正するには~/.gdbinitファイルに以下の行を追加するのが、もっとも簡単な方法です:"

#. type: Plain text
#: DEBUG.orig:66
#, no-wrap
msgid "  add-auto-load-safe-path /path/to/emacs/src/.gdbinit\n"
msgstr "  add-auto-load-safe-path /path/to/emacs/src/.gdbinit\n"

#. type: Plain text
#: DEBUG.orig:71
msgid ""
"There are other ways to overcome that difficulty, they are all described in "
"the node \"Auto-loading safe path\" in the GDB user manual.  If nothing else "
"helps, type \"source /path/to/.gdbinit RET\" at the GDB prompt, to "
"unconditionally load the GDB init file."
msgstr "この問題を克服するための方法は他にもいくつかあり、それらはすべてGDBユーザーマニュアルの\"Auto-loading safe path\"ノードで説明されています。それらでも効果がない場合は、無条件でGDB initファイルをロードするために、GDBプロンプトで\"source /path/to/.gdbinit RET\"とタイプしてください。"

#. type: Plain text
#: DEBUG.orig:73
#, no-wrap
msgid "*** Use the Emacs GDB UI front-end\n"
msgstr "*** EmacsのGDB UIフロントエンドの使用\n"

#. type: Plain text
#: DEBUG.orig:81
msgid ""
"We recommend using the GUI front-end for GDB provided by Emacs.  With it, "
"you can start GDB by typing \"M-x gdb RET\".  This will suggest the file "
"name of the default binary to debug; if the suggested default is not the "
"Emacs binary you want to debug, change the file name as needed.  "
"Alternatively, if you want to attach the debugger to an already running "
"Emacs process, change the GDB command shown in the minibuffer to say this:"
msgstr ""
"わたしたちはEmacsが提供するGDB用のGUIフロントエンドの使用を推奨します。\n"
"We recommend using the GUI front-end for GDB provided by Emacs.\n"
"このフロントエンドは、\"M-x gdb RET\"とタイプしてGDBを開始できます。\n"
"With it, you can start GDB by typing \n"
"このコマンドはデバッグするデフォルトのバイナリーのファイル名を提案します。この提案されるデフォルトが、デバッグしたいEmacsバイナリーと異なる場合は、必要に応じてファイル名を変更してください。かわりに、すでに実行中のEmacsプロセスにデバッガをアタッチしたい場合は、ミニバッファーに表示されているGDBコマンドにそれを告げるように変更します:"

#. type: Plain text
#: DEBUG.orig:83
#, no-wrap
msgid "   gdb -i=mi -p PID\n"
msgstr "   gdb -i=mi -p PID\n"

#. type: Plain text
#: DEBUG.orig:87
msgid ""
"where PID is the numerical process ID of the running Emacs process, "
"displayed by system utilities such as 'top' or 'ps' on Posix hosts and Task "
"Manager on MS-Windows."
msgstr "ここでPIDはPosixホストでは'top'や'ps'のようなシステムユーティリティーで、MS-WindowsではTask Managerで表示される、実行中EmacsのPID数値です。"

#. type: Plain text
#: DEBUG.orig:94
msgid ""
"Once the debugger starts, open the additional windows provided by the GDB "
"UI, by typing \"M-x gdb-many-windows RET\".  (Alternatively, click "
"Gud->GDB-MI->Display Other Windows\" from the menu bar.)  At this point, "
"make your frame large enough (or full-screen) such that the windows you just "
"opened have enough space to show the content without horizontal scrolling."
msgstr "一度デバッガが起動すると\"M-x gdb-many-windows RET\"とタイプすることにより、GDBUIが提供する追加のウィンドウがオープンします(メニューバーの\"Gud->GDB-MI->Display Other Windows\"をクリックしてもオープンできる)。この時点では、オープンしたウィンドウが水平スクロールせずに内容を表示するのに十分なスペースがあるよう、フレームを十分に大きく(またはフルスクリーン)しておいてください。"

#. type: Plain text
#: DEBUG.orig:98
msgid ""
"You can later restore your window configuration with the companion command "
"\"M-x gdb-restore-windows RET\", or by deselecting \"Display Other Windows\" "
"from the menu bar."
msgstr "ウィンドウ構成は後でコマンド\"M-x gdb-restore-windows RET\"、またはメニューバーの\"Display Other Windows\"を選択解除すればリストアできます。"

#. type: Plain text
#: DEBUG.orig:100
#, no-wrap
msgid "*** Setting initial breakpoints\n"
msgstr "*** 初期ブレークポイントのセット\n"

#. type: Plain text
#: DEBUG.orig:108
msgid ""
"Before you let Emacs run, you should now set breakpoints in the code which "
"you want to debug, so that Emacs stops there and lets GDB take control.  If "
"the code which you want to debug is executed under some rare conditions, or "
"only when a certain Emacs command is manually invoked, then just set your "
"breakpoint there, let Emacs run, and trigger the breakpoint by invoking that "
"command or reproducing those rare conditions."
msgstr "Emacsを実行させる前に、デバッガしたいコードにブレークポイントをセットすべきときです。ブレークポイントをセットすればEmacsはそこでストップして、GDBに制御を渡せます。デバッグしたいコードが、ある稀な状況下で実行されるコードであったり、特定のEmacsコマンドを手動で呼び出したときだけ実行されるコードの場合は、そこにブレークポイントをセットしてEmacsを実行すれば、そのコマンドの呼び出し、またはそれらの稀な状況を再現することにより、ブレークポイントがトリガーされます。"

#. type: Plain text
#: DEBUG.orig:115
msgid ""
"If you are less lucky, and the code in question is run very frequently, you "
"will have to find some way of avoiding triggering your breakpoint when the "
"conditions for the buggy behavior did not yet happen.  There's no single "
"recipe for this, you will have to be creative and study the code to see "
"what's appropriate.  Some useful tricks for that:"
msgstr "それほど幸運でなく、問題となっているコードが非常に頻繁に実行される場合は、バグのある振る舞いが発生する条件までブレークポイントがトリガーされないようにする方法を見つける必要があります。これにたいする唯一の処方はありません。あなたはより創造的になるとともに、何が適切か判断するためにコードを学ぶ必要があるでしょう。以下に、これにたいする有用なトリックをいくつか挙げます:"

#. type: Plain text
#: DEBUG.orig:118
#, no-wrap
msgid ""
"  . Make your breakpoint conditional on certain buffer or string\n"
"    position.  For example:\n"
msgstr ""
". ブレークポイント条件を特定のバッファーや文字列の位置にする。\n"
"    たとえば:\n"

#. type: Plain text
#: DEBUG.orig:120
#, no-wrap
msgid "      (gdb) break foo.c:1234 if PT >= 9876\n"
msgstr "      (gdb) break foo.c:1234 if PT >= 9876\n"

#. type: Plain text
#: DEBUG.orig:125
#, no-wrap
msgid ""
"  . Set a break point in some rarely called function, then create the\n"
"    conditions for the bug, call that rare function, and when GDB gets\n"
"    control, set the breakpoint in the buggy code, knowing that it\n"
"    will now be called when the bug happens.\n"
msgstr ""
"  . 稀にしか呼び出されないいくつかの関数にブレークポイントをセットしてから\n"
"    バグにたいする条件を作成して、その稀にしか呼び出されない関数を呼び出す。\n"
"    そしてGDBに制御が渡ったときバグの疑いのあるコードにブレークポイントを\n"
"    セットして、バグが発生するときそのコードが呼び出されるか確認する。\n"

#. type: Plain text
#: DEBUG.orig:129
#, no-wrap
msgid ""
"  . If the bug manifests itself as an error message, set a breakpoint\n"
"    in Fsignal, and when it breaks, look at the backtrace to see what\n"
"    triggers the error.\n"
msgstr ""
"  . エラーメッセージ自体としてバグが顕在化するのであれば、Fsignalに、\n"
"    ブレークポイントをセットして、ブレークしたらbacktraceを調べて\n"
"    何がエラーのトリガーなのか確認する。\n"

#. type: Plain text
#: DEBUG.orig:132
msgid ""
"Some additional techniques are described below under \"Getting control to "
"the debugger\"."
msgstr "他の追加テクニックは、以下の\"デバッガに制御を渡す\"で説明されています。"

#. type: Plain text
#: DEBUG.orig:134
msgid "You are now ready to start your debugging session."
msgstr "これでデバッグセッションを開始する準備ができました。"

#. type: Plain text
#: DEBUG.orig:138
msgid ""
"If you are starting a new Emacs session, type \"run\", followed by any "
"command-line arguments (e.g., \"-Q\") into the *gud-emacs* buffer and press "
"RET."
msgstr "新たなEmacsセッションを開始した場合は、*gud-emacs*バッファー内で\"run\"とタイプした後にコマンドライン引数(例 \"-Q\")を続けてからRETを押下します。"

#. type: Plain text
#: DEBUG.orig:141
msgid ""
"If you attached the debugger to a running Emacs, type \"continue\" into the "
"*gud-emacs* buffer and press RET."
msgstr "実行中のEmacsにデバッガをアタッチした場合は、*gud-emacs*バッファー内で\"continue\"とタイプしてからRETを押下します。"

#. type: Plain text
#: DEBUG.orig:153
msgid ""
"Many variables you will encounter while debugging are Lisp objects.  These "
"are displayed as integer values (or structures, if you used the "
"\"--enable-check-lisp-object-type\" option at configure time) that are hard "
"to interpret, especially if they represent long lists.  You can use the 'pp' "
"command to display them in their Lisp form.  That command displays its "
"output on the standard error stream (on GNU/Linux, you can redirect that to "
"a file using \"M-x redirect-debugging-output\").  This means that if you "
"attach GDB to a running Emacs that was invoked from a desktop icon, chances "
"are you will not see the output at all, or it will wind up in an obscure "
"place (check the documentation of your desktop environment)."
msgstr "Lispオブジェクトをデバッガする間、多くの変数に出会うことでしょう。これらは整数値(configure時に\"--enable-check-lisp-object-type\"オプションを使用した場合は構造体)なので解釈が困難であり、とりわけ長いリストで表現されている場合は困難です。これらをLisp形式で表示するために、'pp'コマンドを使用できます。このコマンドは出力を標準エラーストリーム(GNU/Linuxシステムでは\"M-x redirect-debugging-output\"を使用してファイルにリダイレクトできます)に表示します。これはデスクトップアイコンから呼び出された実行中のEmacsにGDBをアタッチした場合に、出力を確認できなかったり、出力がどこか不明な場所(デスクトップ環境のドキュメントをチェックしてください)に切り捨てられる危険があることを意味します。"

#. type: Plain text
#: DEBUG.orig:156
msgid ""
"Additional information about displaying Lisp objects can be found under "
"\"Examining Lisp object values\" below."
msgstr "Lispオブジェクトの表示に関する追加情報は、以下の\"Lispオブジェクトの値の調査\"で見つけることができます。"

#. type: Plain text
#: DEBUG.orig:161
msgid ""
"The rest of this document describes specific useful techniques for debugging "
"Emacs; we suggest reading it in its entirety the first time you are about to "
"debug Emacs, then look up your specific issues whenever you need."
msgstr "このドキュメントの残りの部分は、Emacsのデバッグにおいて特に有用なテクニックを説明します。初めてEmacsをデバッグしようとするときは全体をありのまま目を通しておいて、必要なときに特定の問題を参照するよう、わたしたちは提案します。"

#. type: Plain text
#: DEBUG.orig:163
msgid "Good luck!"
msgstr "Good luck!"

#. type: Plain text
#: DEBUG.orig:180
#, no-wrap
msgid ""
"** When you are trying to analyze failed assertions or backtraces, it\n"
"is essential to compile Emacs with flags suitable for debugging.\n"
"With GCC 4.8 or later, you can invoke 'make' with CFLAGS=\"-Og -g3\".\n"
"With older GCC or non-GCC compilers, you can use CFLAGS=\"-O0 -g3\".\n"
"With GCC and higher optimization levels such as -O2, the\n"
"-fno-omit-frame-pointer and -fno-crossjumping options are often\n"
"essential.  The latter prevents GCC from using the same abort call for\n"
"all assertions in a given function, rendering the stack backtrace\n"
"useless for identifying the specific failed assertion.\n"
"Some versions of GCC support recent versions of the DWARF standard for\n"
"debugging info, but default to older versions; for example, they could\n"
"support -gdwarf-4 compiler option (for DWARF v4), but default to\n"
"version 2 of the DWARF standard.  For best results in debugging\n"
"abilities, find out the highest version of DWARF your GCC can support,\n"
"and use the corresponding -gdwarf-N switch instead of just -g (you\n"
"will still need -g3, as in \"-gdwarf-4 -g3\").\n"
msgstr ""
"** assertの失敗やバックトレースの分析をするときはデバッグに適した\n"
"フラグでEmacsをコンパイルするのが不可欠です。\n"
"GCC4.8以降では、CFLAGS=\"-Og -g3\".で'make'を呼び出すことができます。\n"
"それより古いGCCやGCC以外のコンパイラーではCFLAGS=\"-O0 -g3\"を使用できます。\n"
"GCCで-O2のような、より高レベルの最適化においては、-fno-omit-frame-pointer\n"
"および-fno-crossjumpingオプションが不可欠な場合がしばしばあります。\n"
"後者のオプションは与えられた関数内のすべてのassertionにたいして\n"
"GCCが同じabort呼び出しを使用することを抑制し、失敗した特定のassertion\n"
"を識別できないときはスタックバックトレースで表します。\n"
"GCCのいくつかのバージョンはデバッグ情報にたいし最新バージョンのDWARF標準を\n"
"サポートしますが、デフォルトは古いバージョンになっています。\n"
"たとえば、それらのGCCは-gdwarf-4(DWARF v4)をサポートしますが、\n"
"デフォルトはDWARF標準のバージョン2です。\n"
"デバッグ手法において最良の結果を得るために、あなたのGCCがサポート可能な\n"
"最新バージョンのDWARFを調べて、単なる-gのかわりに、対応するバージョンの\n"
"-gdwarf-Nスイッチを使用してください。\n"
"(とはいえ、\"-gdwarf-4 -g3\"のように-g3の指定は依然として必要です。)\n"

#. type: Plain text
#: DEBUG.orig:186
#, no-wrap
msgid ""
"** It is a good idea to run Emacs under GDB (or some other suitable\n"
"debugger) *all the time*.  Then, when Emacs crashes, you will be able\n"
"to debug the live process, not just a core dump.  (This is especially\n"
"important on systems which don't support core files, and instead print\n"
"just the registers and some stack addresses.)\n"
msgstr ""
"** GDB(および他の適切なデバッガ)配下でEmacsを実行するのは*いかなるときも*\n"
"よいアイデアです。その後にEmacsがクラッシュしても、単なるcoreダンプではなく、\n"
"生きたプロセスをデバッグできます。\n"
"(これはcoreファイルをサポートしないシステムでは特に重要で、単にレジスターと\n"
"いくつかのスタックアドレスをプリントするかわりになります。)\n"

#. type: Plain text
#: DEBUG.orig:190
#, no-wrap
msgid ""
"** If Emacs hangs, or seems to be stuck in some infinite loop, typing\n"
"\"kill -TSTP PID\", where PID is the Emacs process ID, will cause GDB to\n"
"kick in, provided that you run under GDB.\n"
msgstr ""
"** Emacsが固まったり、何らかの無限ループに嵌っているように見える場合は、\n"
"\"kill -TSTP PID\"とタイプします。ここでPIDはEmacsのプロセスIDです。\n"
"これによりGDB配下で実行されていれば、GDBが動作を開始します。\n"

#. type: Plain text
#: DEBUG.orig:192
#, no-wrap
msgid "** Getting control to the debugger\n"
msgstr "** デバッガに制御を渡す\n"

#. type: Plain text
#: DEBUG.orig:197
msgid ""
"Setting a breakpoint in a strategic place, after loading Emacs into the "
"debugger, but before running it, is the most efficient way of making sure "
"control will be returned to the debugger when you need that."
msgstr "デバッガにEmacsをロードした後で、それを実行する前に効果的な場所にブレークポイントをセットすることは、必要なときにデバッガに確実に制御をリターンさせるもっとも効果的な方法です。"

#. type: Plain text
#: DEBUG.orig:202
msgid ""
"'Fsignal' is a very useful place to put a breakpoint in.  All Lisp errors go "
"through there.  If you are only interested in errors that would fire the "
"Lisp debugger, breaking at 'maybe_call_debugger' is useful."
msgstr "'Fsignal'はブレークポイントを配すのに、とても役に立つ場所です。すべてのLispエラーはここを通過します。Lispデバッガを起動させるエラーだけに関心がある場合は、'maybe_call_debugger'にブレークポイントを置くのが役に立つでしょう。"

#. type: Plain text
#: DEBUG.orig:207
msgid ""
"Another technique for get control to the debugger is to put a breakpoint in "
"some rarely used function.  One such convenient function is Fredraw_display, "
"which you can invoke at will interactively with \"M-x redraw-display RET\"."
msgstr "デバッガに制御を渡す他のテクニックとして、稀に使用されるいくつかの関数にブレークポイントを配す方法があります。そのような便利な関数の1つがFredraw_displayで、これは\"M-x redraw-display RET\"でインタラクティブに呼び出すことができます。"

#. type: Plain text
#: DEBUG.orig:215
msgid ""
"It is also useful to have a guaranteed way to return to the debugger at any "
"arbitrary time.  When using X, this is easy: type C-z at the window where "
"you are interacting with GDB, and it will stop Emacs just as it would stop "
"any ordinary program.  (This doesn't work if GDB was attached to a running "
"Emacs process; in that case, you will need to type C-z to the shell window "
"from which Emacs was started, or use the \"kill -TSTP\" method described "
"below.)"
msgstr "任意のタイミングでデバッガにリターンするために、保証された方法があるのも便利です。これはXを使用しているときは簡単です。GDBで対話中のウィンドウでC-zをタイプすれば、普通のプログラムと同様にEmacsもストップします。(これは実行中のEmacsにアタッチされたGDBでは機能しません。この場合はEmacsを起動したシェルのウィンドウでC-zとタイプするか、以下で説明している\"kill -TSTP\"手法を使用する必要があるでしょう。)"

#. type: Plain text
#: DEBUG.orig:219
msgid ""
"When Emacs is displaying on a text terminal, things are not so easy, so we "
"describe the various alternatives below (however, those of them that use "
"signals only work on Posix systems)."
msgstr "Emacsがテキスト端末で表示されているときは、事はそれほど簡単ではないので、以下で他のさまざまな方法を説明します(とはいえ、それらはPosixシステムだけでキンするシグナルを使用した場合のみ機能します)。"

#. type: Plain text
#: DEBUG.orig:224
msgid ""
"The src/.gdbinit file in the Emacs distribution arranges for SIGINT (C-g in "
"Emacs on a text-mode frame) to be passed to Emacs and not give control back "
"to GDB.  On modern systems, you can override that with this command:"
msgstr "Emacsディストリビューション内のsrc/.gdbinitファイルはSIGINT(Emacsのtext-modeのフレームでのC-g)をGDBに制御を戻さずにEmacsに渡されるようアレンジしています。モダンなシステムでは、以下のコマンドでこれをオーバーライドできます:"

#. type: Plain text
#: DEBUG.orig:226
#, no-wrap
msgid "   handle SIGINT stop nopass\n"
msgstr "   handle SIGINT stop nopass\n"

#. type: Plain text
#: DEBUG.orig:231
msgid ""
"After this 'handle' command, SIGINT will return control to GDB.  If you want "
"the C-g to cause a QUIT within Emacs as well, omit the 'nopass'.  See the "
"GDB manual for more details about signal handling and the 'handle' command."
msgstr "この'handle'コマンドの後は、SIGINTにより制御がGDBのリターンされるでしょう。Emacsにも同様にC-gでQUITを送りたい場合は、'nopass'を省略してください。シグナルのハンドリングと'handle'コマンドについての詳細は、GDBのマニュアルを参照してください。"

#. type: Plain text
#: DEBUG.orig:234
msgid ""
"A technique that can work when 'handle SIGINT' does not is to store the code "
"for some character into the variable stop_character.  Thus,"
msgstr "'handle SIGINT'が機能しない場合に使えるテクニックは、何らかの文字コードを変数stop_characterに格納する方法です。したがって、"

#. type: Plain text
#: DEBUG.orig:236
#, no-wrap
msgid "    set stop_character = 29\n"
msgstr "    set stop_character = 29\n"

#. type: Plain text
#: DEBUG.orig:242
msgid ""
"makes Control-] (decimal code 29) the stop character.  Typing Control-] will "
"cause immediate stop.  You cannot use the set command until the inferior "
"process has been started, so start Emacs with the 'start' command, to get an "
"opportunity to do the above 'set' command."
msgstr "これはControl-](10進の29)をストップ文字にします。これでControl-]をタイプすれば、即座にストップします。下位プロセスが開始されるまでsetコマンドは使用できないので、上述の'set'コマンドの機会を得るために、Emacsを'start'コマンドで開始してください。"

#. type: Plain text
#: DEBUG.orig:245
msgid ""
"On a Posix host, you can also send a signal using the 'kill' command from a "
"shell prompt, like this:"
msgstr "Posixホストでは、以下のようにシェルプロンプトから'kill'コマンドを使用してシグナルを送ることもできます。"

#. type: Plain text
#: DEBUG.orig:247
#, no-wrap
msgid "   kill -TSTP Emacs-PID\n"
msgstr "   kill -TSTP Emacs-PID\n"

#. type: Plain text
#: DEBUG.orig:251
msgid ""
"where Emacs-PID is the process ID of Emacs being debugged.  Other useful "
"signals to send are SIGUSR1 and SIGUSR2; see \"Error Debugging\" in the "
"ELisp manual for how to use those."
msgstr "ここでEmacs-PIDはデバッグされているEmacsのプロセスIDです。他に送信するシグナルとして有用なのがSIGUSR1とSIGUSR2です。これらのシグナルの使い方は、ELispマニュアルの\"Error Debugging\"を参照してください。"

#. type: Plain text
#: DEBUG.orig:256
msgid ""
"When Emacs is displaying on a text terminal, it is useful to have a separate "
"terminal for the debug session.  This can be done by starting Emacs as "
"usual, then attaching to it from gdb with the 'attach' command which is "
"explained in the node \"Attach\" of the GDB manual."
msgstr "Emacsがテキスト端末で表示されているときは、デバッグセッション用に別の端末があると便利です。これは通常どおりEmacsを開始して、gdbから'attach'コマンドでアタッチして行うことができます。このコマンドは、GDBマニュアルの\"Attach\"ノードで説明されています。"

#. type: Plain text
#: DEBUG.orig:260
msgid ""
"On MS-Windows, you can alternatively start Emacs from its own separate "
"console by setting the new-console option before running Emacs under GDB:"
msgstr "MS-WindowsではGDB配下でEmacsを実行する前にnew-consoleオプションをセットすることにより、別のコンソールからEmacsを開始できます。"

#. type: Plain text
#: DEBUG.orig:263 DEBUG.orig:887
#, no-wrap
msgid ""
"  (gdb) set new-console 1\n"
"  (gdb) run\n"
msgstr ""
"  (gdb) set new-console 1\n"
"  (gdb) run\n"

#. type: Plain text
#: DEBUG.orig:269
msgid ""
"If you do this, then typing C-c or C-BREAK into the console window through "
"which you interact with GDB will stop Emacs and return control to the "
"debugger, no matter if Emacs displays GUI or text-mode frames.  This is the "
"only reliable alternative on MS-Windows to get control to the debugger, "
"besides setting breakpoints in advance."
msgstr "これを行なった場合、GDBと対話しているコンソールウィンドウからC-cやC-BREAKをタイプすると、EmacsがGUIかtext-modeフレームで表示されているかに関わらず、Emacsはストップして制御がGDBにリターンされるでしょう。これは、事前にブレークポイントをセットする以外に、MS-Windowsでデバッガが制御を得るための唯一信頼できる代替方法です。"

#. type: Plain text
#: DEBUG.orig:271
#, no-wrap
msgid "** Examining Lisp object values.\n"
msgstr "** Lispオブジェクトの値の調査\n"

#. type: Plain text
#: DEBUG.orig:276
msgid ""
"When you have a live process to debug, and it has not encountered a fatal "
"error, you can use the GDB command 'pr'.  First print the value in the "
"ordinary way, with the 'p' command.  Then type 'pr' with no arguments.  This "
"calls a subroutine which uses the Lisp printer."
msgstr "デバッグの生きたプロセスがあり、致命的なエラーに遭遇戦していなければ、GDBコマンド'pr'を使用できます。最初は通常の方法、'p'コマンドで値をプリントしてください。それから引数なしで'pr'とタイプします。これはLispプリンターを使用するサブルーチンを呼び出します。"

#. type: Plain text
#: DEBUG.orig:278
msgid "You can also use 'pp value' to print the emacs value directly."
msgstr "emacsの値を直接プリントするために、'pp value'を使用することもできます。"

#. type: Plain text
#: DEBUG.orig:280
msgid "To see the current value of a Lisp Variable, use 'pv variable'."
msgstr "Lisp変数のカレント値を確認するためには、'pv value'を使用します。"

#. type: Plain text
#: DEBUG.orig:286
msgid ""
"These commands send their output to stderr; if that is closed or redirected "
"to some file you don't know, you won't see their output.  This is "
"particularly so for Emacs invoked on MS-Windows from the desktop shortcut.  "
"On GNU/Linux, you can use the command 'redirect-debugging-output' to "
"redirect stderr to a file."
msgstr "これらのコマンドは出力をstderrに送ります。stderrがcloseされていたり、あなたには不明な何らかのファイルにリダイレクトされている場合、これらの出力を確認することはできないでしょう。これは特にMS-Windows上でデスクトップショートカットからEmacsが呼び出された場合が該当します。GNU/Linuxではコマンド'redirect-debugging-output'を使用して、stderrをファイルにリダイレクトできます。"

#. type: Plain text
#: DEBUG.orig:293
msgid ""
"Note: It is not a good idea to try 'pr', 'pp', or 'pv' if you know that "
"Emacs is in deep trouble: its stack smashed (e.g., if it encountered SIGSEGV "
"due to stack overflow), or crucial data structures, such as 'obarray', "
"corrupted, etc.  In such cases, the Emacs subroutine called by 'pr' might "
"make more damage, like overwrite some data that is important for debugging "
"the original problem."
msgstr "注意: Emacsが深刻なトラブルの渦中、スタックが破壊(たとえばスタックオーバーフローによるSIGSEGVなど)されていたり、'obarray'のようなデータ構造の循環参照や不正構造があると解っている状況で'pr'、'pp'、'pv'を試みるのは、良いアイデアではありません。このような場合、'pr'により呼び出されるEmacsサブルーチンは、元の問題をデバッグするために重要な何らかのデータを上書きしてしまう等、より多くのダメージを与えてしまうかもしれません。"

#. type: Plain text
#: DEBUG.orig:299
msgid ""
"Also, on some systems it is impossible to use 'pr' if you stopped Emacs "
"while it was inside 'select'.  This is in fact what happens if you stop "
"Emacs while it is waiting.  In such a situation, don't try to use 'pr'.  "
"Instead, use 's' to step out of the system call.  Then Emacs will be between "
"instructions and capable of handling 'pr'."
msgstr "さらに'select'の内部にいる間にEmacsをストップした場合は、'pr'の使用が不可能なシステムもいくつかあります。Emacsがwaitしている間にEmacsをストップすると、これは実際に発生します。このような状況では、'pr'の使用を試みてはなりません。かわりにシステムコールをステップアウトするために、's'を使用してください。その後、Emacsは命令文の間に、'pr'を処理することができるようになるでしょう。"

#. type: Plain text
#: DEBUG.orig:303
msgid ""
"If you can't use 'pr' command, for whatever reason, you can use the 'xpr' "
"command to print out the data type and value of the last data value, For "
"example:"
msgstr "理由が何であれ、'pr'コマンドが使用できない場合は、直前のデータ値のデータ型と値をプリントする'xpr'コマンドを使用できます。"

#. type: Plain text
#: DEBUG.orig:306
#, no-wrap
msgid ""
"    p it->object\n"
"    xpr\n"
msgstr ""
"    p it->object\n"
"    xpr\n"

#. type: Plain text
#: DEBUG.orig:311
msgid ""
"You may also analyze data values using lower-level commands.  Use the "
"'xtype' command to print out the data type of the last data value.  Once you "
"know the data type, use the command that corresponds to that type.  Here are "
"these commands:"
msgstr "低レベルコマンドを使用して、データ値を分析するかもしれません。直前のデータ値のデータ型のプリントには、'xtype'コマンドを使用します。一度データ型が解れば、その型に対応するコマンドを使用できます。以下はそれらのコマンドです:"

#. type: Plain text
#: DEBUG.orig:317
#, no-wrap
msgid ""
"    xint xptr xwindow xmarker xoverlay xmiscfree xintfwd xboolfwd xobjfwd\n"
"    xbufobjfwd xkbobjfwd xbuflocal xbuffer xsymbol xstring xvector xframe\n"
"    xwinconfig xcompiled xcons xcar xcdr xsubr xprocess xfloat xscrollbar\n"
"    xchartable xsubchartable xboolvector xhashtable xlist xcoding\n"
"    xcharset xfontset xfont xbytecode\n"
msgstr ""
"    xint xptr xwindow xmarker xoverlay xmiscfree xintfwd xboolfwd xobjfwd\n"
"    xbufobjfwd xkbobjfwd xbuflocal xbuffer xsymbol xstring xvector xframe\n"
"    xwinconfig xcompiled xcons xcar xcdr xsubr xprocess xfloat xscrollbar\n"
"    xchartable xsubchartable xboolvector xhashtable xlist xcoding\n"
"    xcharset xfontset xfont xbytecode\n"

#. type: Plain text
#: DEBUG.orig:321
msgid ""
"Each one of them applies to a certain type or class of types.  (Some of "
"these types are not visible in Lisp, because they exist only internally.)"
msgstr "これらの1つ1つは、特定の型やクラス型を受け入れます(これらの型のいくつかは内部的にのみ存在する型なので、Lispでは不可視です)。"

#. type: Plain text
#: DEBUG.orig:325
msgid ""
"Each x... command prints some information about the value, and produces a "
"GDB value (subsequently available in $) through which you can get at the "
"rest of the contents."
msgstr "それぞれのx...コマンドは、その内容の残りから得られるものを通じて、値についてのいくつかの情報と、GDB値(続けて$により利用可能)をプリントします。"

#. type: Plain text
#: DEBUG.orig:328
msgid ""
"In general, most of the rest of the contents will be additional Lisp objects "
"which you can examine in turn with the x... commands."
msgstr "一般的に内容の残りのほとんどはx...コマンドで順に検証していくことができる、追加のLispオブジェクトでしょう。"

#. type: Plain text
#: DEBUG.orig:334
msgid ""
"Even with a live process, these x...  commands are useful for examining the "
"fields in a buffer, window, process, frame or marker.  Here's an example "
"using concepts explained in the node \"Value History\" of the GDB manual to "
"print values associated with the variable called frame.  First, use these "
"commands:"
msgstr "生きたプロセスにおいても、これらのx...コマンドはバッファー、ウィンドウ、プロセス、マーカー内の検証に役立ちます。以下はフレームと呼ばれる変数に関連する値をプリントするために、GDBマニュアル\"Value History\"ノードで説明されている概念を使用する例です:"

#. type: Plain text
#: DEBUG.orig:339
#, no-wrap
msgid ""
"  cd src\n"
"  gdb emacs\n"
"  b set_frame_buffer_list\n"
"  r -q\n"
msgstr ""
"  cd src\n"
"  gdb emacs\n"
"  b set_frame_buffer_list\n"
"  r -q\n"

#. type: Plain text
#: DEBUG.orig:341
msgid "Then Emacs hits the breakpoint:"
msgstr "その後、Emacsはブレークポイントに達します:"

#. type: Plain text
#: DEBUG.orig:356
#, no-wrap
msgid ""
"  (gdb) p frame\n"
"  $1 = 139854428\n"
"  (gdb) xpr\n"
"  Lisp_Vectorlike\n"
"  PVEC_FRAME\n"
"  $2 = (struct frame *) 0x8560258\n"
"  \"emacs@localhost\"\n"
"  (gdb) p *$\n"
"  $3 = {\n"
"    size = 1073742931,\n"
"    next = 0x85dfe58,\n"
"    name = 140615219,\n"
"    [...]\n"
"  }\n"
msgstr ""
"  (gdb) p frame\n"
"  $1 = 139854428\n"
"  (gdb) xpr\n"
"  Lisp_Vectorlike\n"
"  PVEC_FRAME\n"
"  $2 = (struct frame *) 0x8560258\n"
"  \"emacs@localhost\"\n"
"  (gdb) p *$\n"
"  $3 = {\n"
"    size = 1073742931,\n"
"    next = 0x85dfe58,\n"
"    name = 140615219,\n"
"    [...]\n"
"  }\n"

#. type: Plain text
#: DEBUG.orig:358
msgid "Now we can use 'pp' to print the frame parameters:"
msgstr "これで'pp'を使用してフレームパラメーターをプリントできます:"

#. type: Plain text
#: DEBUG.orig:361
#, no-wrap
msgid ""
"  (gdb) pp $->param_alist\n"
"  ((background-mode . light) (display-type . color) [...])\n"
msgstr ""
"  (gdb) pp $->param_alist\n"
"  ((background-mode . light) (display-type . color) [...])\n"

#. type: Plain text
#: DEBUG.orig:365
msgid ""
"The Emacs C code heavily uses macros defined in lisp.h.  So suppose we want "
"the address of the l-value expression near the bottom of 'add_command_key' "
"from keyboard.c:"
msgstr "EmacsのCコードは、lisp.h内で定義されたマクロを多用します。keyboard.cの'add_command_key'の最後の方にある左辺値式(l-value expression)のアドレスが知りたいとします:"

#. type: Plain text
#: DEBUG.orig:367
#, no-wrap
msgid "  XVECTOR (this_command_keys)->contents[this_command_key_count++] = key;\n"
msgstr "  XVECTOR (this_command_keys)->contents[this_command_key_count++] = key;\n"

#. type: Plain text
#: DEBUG.orig:372
msgid ""
"XVECTOR is a macro, so GDB only knows about it if Emacs has been compiled "
"with preprocessor macro information.  GCC provides this if you specify the "
"options '-gdwarf-N' (where N is 2 or higher) and '-g3'.  In this case, GDB "
"can evaluate expressions like \"p XVECTOR (this_command_keys)\"."
msgstr "XVECTORはマクロなので、Emacsがプリプロセッサーマクロ情報とともにコンパイルされた場合だけそれを知ることができます。オプション'-gdwarf-N'(Nは2以上)と'-g3'を指定した場合、GCCはこの情報を提供します。この場合、GDBは\"p XVECTOR (this_command_keys)\"のような式を評価できます。"

#. type: Plain text
#: DEBUG.orig:375
msgid ""
"When this information isn't available, you can use the xvector command in "
"GDB to get the same result.  Here is how:"
msgstr "この情報が利用できない場合は、同じ結果を得るためにGDB内でxvectorコマンドを使用できます。以下は使用方法です:"

#. type: Plain text
#: DEBUG.orig:385
#, no-wrap
msgid ""
"  (gdb) p this_command_keys\n"
"  $1 = 1078005760\n"
"  (gdb) xvector\n"
"  $2 = (struct Lisp_Vector *) 0x411000\n"
"  0\n"
"  (gdb) p $->contents[this_command_key_count]\n"
"  $3 = 1077872640\n"
"  (gdb) p &$\n"
"  $4 = (int *) 0x411008\n"
msgstr ""
"  (gdb) p this_command_keys\n"
"  $1 = 1078005760\n"
"  (gdb) xvector\n"
"  $2 = (struct Lisp_Vector *) 0x411000\n"
"  0\n"
"  (gdb) p $->contents[this_command_key_count]\n"
"  $3 = 1077872640\n"
"  (gdb) p &$\n"
"  $4 = (int *) 0x411008\n"

#. type: Plain text
#: DEBUG.orig:389
msgid ""
"Here's a related example of macros and the GDB 'define' command.  There are "
"many Lisp vectors such as 'recent_keys', which contains the last 300 "
"keystrokes.  We can print this Lisp vector"
msgstr "以下はマクロとGDBの'define'コマンドに関する例です。'recent_keys'(最後のキーストローク300個を含む)のようなLispベクターが多数存在します。このLispベクターを以下のようにしてプリントできます"

#. type: Plain text
#: DEBUG.orig:392
#, no-wrap
msgid ""
"  p recent_keys\n"
"  pr\n"
msgstr ""
"  p recent_keys\n"
"  pr\n"

#. type: Plain text
#: DEBUG.orig:396
msgid ""
"But this may be inconvenient, since 'recent_keys' is much more verbose than "
"'C-h l'.  We might want to print only the last 10 elements of this vector.  "
"'recent_keys' is updated in keyboard.c by the command"
msgstr "'recent_keys'は'C-h l'に比べて出力が多く、これは不便かもしれません。わたしたちなら、このベクターの最後の10要素だけをプリントしたいと望むでしょう。'recent_keys'はkeyboard.c内でコマンドにより更新されます"

#. type: Plain text
#: DEBUG.orig:398
#, no-wrap
msgid "  XVECTOR (recent_keys)->contents[recent_keys_index] = c;\n"
msgstr "  XVECTOR (recent_keys)->contents[recent_keys_index] = c;\n"

#. type: Plain text
#: DEBUG.orig:401
msgid ""
"So we define a GDB command 'xvector-elts', so the last 10 keystrokes are "
"printed by"
msgstr "わたしたちはGDBコマンド'xvector-elts'を定義して、以下のように最後のキーストローク10個をプリントします"

#. type: Plain text
#: DEBUG.orig:403
#, no-wrap
msgid "  xvector-elts recent_keys recent_keys_index 10\n"
msgstr "  xvector-elts recent_keys recent_keys_index 10\n"

#. type: Plain text
#: DEBUG.orig:405
msgid "where you can define xvector-elts as follows:"
msgstr "ここでxvector-eltsは以下のように定義します:"

#. type: Plain text
#: DEBUG.orig:420
#, no-wrap
msgid ""
"  define xvector-elts\n"
"  set $i = 0\n"
"  p $arg0\n"
"  xvector\n"
"  set $foo = $\n"
"  while $i < $arg2\n"
"  p $foo->contents[$arg1-($i++)]\n"
"  pr\n"
"  end\n"
"  document xvector-elts\n"
"  Prints a range of elements of a Lisp vector.\n"
"  xvector-elts  v n i\n"
"  prints 'i' elements of the vector 'v' ending at the index 'n'.\n"
"  end\n"
msgstr ""
"  define xvector-elts\n"
"  set $i = 0\n"
"  p $arg0\n"
"  xvector\n"
"  set $foo = $\n"
"  while $i < $arg2\n"
"  p $foo->contents[$arg1-($i++)]\n"
"  pr\n"
"  end\n"
"  document xvector-elts\n"
"  Prints a range of elements of a Lisp vector.\n"
"  xvector-elts  v n i\n"
"  prints 'i' elements of the vector 'v' ending at the index 'n'.\n"
"  end\n"

#. type: Plain text
#: DEBUG.orig:422
#, no-wrap
msgid "** Getting Lisp-level backtrace information within GDB\n"
msgstr "** GDBでLispレベルのバックトレース情報を取得する\n"

#. type: Plain text
#: DEBUG.orig:425
msgid ""
"The most convenient way is to use the 'xbacktrace' command.  This shows the "
"names of the Lisp functions that are currently active."
msgstr "'xbacktrace'コマンドを使用するのがもっとも便利な方法です。これはカレントでアクティブなLisp関数の名前を表示します。"

#. type: Plain text
#: DEBUG.orig:431
msgid ""
"If that doesn't work (e.g., because the 'backtrace_list' structure is "
"corrupted), type \"bt\" at the GDB prompt, to produce the C-level backtrace, "
"and look for stack frames that call Ffuncall.  Select them one by one in "
"GDB, by typing \"up N\", where N is the appropriate number of frames to go "
"up, and in each frame that calls Ffuncall type this:"
msgstr "もしこれが機能しない(たとえば'backtrace_list'構造が不正等により)場合は、Cレベルのバックトレースを生成するために、GDBプロンプトで\"bt\"とタイプして、Ffuncallを呼び出しているスタックフレームを探してください。\"up N\"とタイプして、それらのスタックフレームをGDBで1つずつ選択していきます。ここでNは上位フレームに移動するための適切な数字です。そしてFfuncallを呼び出しているフレームごとに以下をタイプします:"

#. type: Plain text
#: DEBUG.orig:434
#, no-wrap
msgid ""
"   p *args\n"
"   pr\n"
msgstr ""
"   p *args\n"
"   pr\n"

#. type: Plain text
#: DEBUG.orig:437
msgid ""
"This will print the name of the Lisp function called by that level of "
"function calling."
msgstr "これにより、そのレベルの関数呼び出しにより呼び出されているLisp関数の名前がプリントされます。"

#. type: Plain text
#: DEBUG.orig:440
msgid ""
"By printing the remaining elements of args, you can see the argument "
"values.  Here's how to print the first argument:"
msgstr "argsの残りの要素をプリントすることにより、Lisp関数の引数の値を確認できます。以下は最初の引数をプリントする方法です:"

#. type: Plain text
#: DEBUG.orig:443
#, no-wrap
msgid ""
"   p args[1]\n"
"   pr\n"
msgstr ""
"   p args[1]\n"
"   pr\n"

#. type: Plain text
#: DEBUG.orig:447
msgid ""
"If you do not have a live process, you can use xtype and the other x...  "
"commands such as xsymbol to get such information, albeit less conveniently.  "
"For example:"
msgstr "生きたプロセスがない場合は、xtypeと他のx...コマンドを使用できます。便利さは劣りますが、このような情報はxsymbolのようなコマンドで取得します。たとえば、"

#. type: Plain text
#: DEBUG.orig:450
#, no-wrap
msgid ""
"   p *args\n"
"   xtype\n"
msgstr ""
"   p *args\n"
"   xtype\n"

#. type: Plain text
#: DEBUG.orig:452
msgid "and, assuming that \"xtype\" says that args[0] is a symbol:"
msgstr "\"xtype\"が、args[0]をsymbolだと告げた場合は:"

#. type: Plain text
#: DEBUG.orig:454
#, no-wrap
msgid "   xsymbol\n"
msgstr "   xsymbol\n"

#. type: Plain text
#: DEBUG.orig:456
#, no-wrap
msgid "** Debugging Emacs redisplay problems\n"
msgstr "** Emacsの再表示に関する問題のデバッグ\n"

#. type: Plain text
#: DEBUG.orig:459
msgid ""
"If you configured Emacs with --enable-checking='glyphs', you can use "
"redisplay tracing facilities from a running Emacs session."
msgstr "--enable-checking='glyphs'でEmacsをconfigureした場合は、実行中のEmacsセッションから再表示(redisplay)トレース機能を使用できます。"

#. type: Plain text
#: DEBUG.orig:470
msgid ""
"The command \"M-x trace-redisplay RET\" will produce a trace of what "
"redisplay does on the standard error stream.  This is very useful for "
"understanding the code paths taken by the display engine under various "
"conditions, especially if some redisplay optimizations produce wrong "
"results.  (You know that redisplay optimizations might be involved if \"M-x "
"redraw-display RET\", or even just typing \"M-x\", causes Emacs to correct "
"the bad display.)  Since the cursor blinking feature triggers periodic "
"redisplay cycles, we recommend disabling 'blink-cursor-mode' before invoking "
"'trace-redisplay', so that you have less clutter in the trace.  You can also "
"have up to 30 last trace messages dumped to standard error by invoking the "
"'dump-redisplay-history' command."
msgstr "コマンド\"M-x trace-redisplay RET\"は再表示が行うことのトレースを標準エラーストリームに生成します。さまざまな状況下でディスプレイエンジンにより選択されるコードパス(code path:実際に実行されるコードの道筋)を理解するために、特にある再表示最適化が誤った結果を生成する場合に、非常に役に立ちます(承知のとおり、\"M-x redraw-display RET\"、あるいは\"M-x\"とタイプするだけでも、Emacsが誤った表示を修正するために再表示最適化がよびだされます)。カーソル点滅機能(cursor blinking feature)は定期的な再表示サイクルをトリガーするので、余計なものをトレースから減らすために、'trace-redisplay'を呼び出す前に'blink-cursor-mode'を無効にすることを推奨します。dump-redisplay-history'コマンドを呼び出して、最後のトレースメッセージを30個まで標準エラーにダンプすることもできます。"

#. type: Plain text
#: DEBUG.orig:473
msgid ""
"To find the code paths which were taken by the display engine, search "
"xdisp.c for the trace messages you see."
msgstr "ディスプレイエンジンが選択するコードパスを見つけるには、トレースメッセージからxdisp.cを探します。"

#. type: Plain text
#: DEBUG.orig:478
msgid ""
"The command 'dump-glyph-matrix' is useful for producing on standard error "
"stream a full dump of the selected window's glyph matrix.  See the "
"function's doc string for more details.  If you are debugging redisplay "
"issues in text-mode frames, you may find the command "
"'dump-frame-glyph-matrix' useful."
msgstr "コマンド'dump-glyph-matrix'は、選択されたウィンドウのグリフマトリクス(glyph matrix)の完全なダンプを標準エラーストリームに生成するのに役立ちます。詳細は関数のドキュメント文字列を参照してください。text-modeフレームで再表示に関する問題をデバッグしている場合は、コマンド'dump-frame-glyph-matrix'が便利なことに気づくかもしれません。"

#. type: Plain text
#: DEBUG.orig:481
msgid ""
"Other commands useful for debugging redisplay are 'dump-glyph-row' and "
"'dump-tool-bar-row'."
msgstr "再表示をデバッグするとき有用な他のコマンドには、'dump-glyph-row'と'dump-tool-bar-row'があります。"

#. type: Plain text
#: DEBUG.orig:486
msgid ""
"If you run Emacs under GDB, you can print the contents of any glyph matrix "
"by just calling that function with the matrix as its argument.  For example, "
"the following command will print the contents of the current matrix of the "
"window whose pointer is in 'w':"
msgstr "GDB配下でEmacsを実行している場合は、マトリクスを引数にその関数を呼び出すだけで、任意のグリフマトリクスの内容をプリントできます。たとえば、以下のコマンドは、ウィンドウ(ポインター'w')のカレントマトリクスの内容をプリントします:"

#. type: Plain text
#: DEBUG.orig:488
#, no-wrap
msgid "  (gdb) p dump_glyph_matrix (w->current_matrix, 2)\n"
msgstr "  (gdb) p dump_glyph_matrix (w->current_matrix, 2)\n"

#. type: Plain text
#: DEBUG.orig:491
msgid ""
"(The second argument 2 tells dump_glyph_matrix to print the glyphs in a long "
"form.)"
msgstr "(2つ目の引数2はdump_glyph_matrixにグリフを長い形式プリントするよう指定します。)"

#. type: Plain text
#: DEBUG.orig:494
msgid ""
"The Emacs display code includes special debugging code, but it is normally "
"disabled.  Configuring Emacs with --enable-checking='yes,glyphs' enables it."
msgstr "ディスプレイ関係のEmacsのコードには特別なデバッグ用コードが含まれていますが、通常は無効になっています。--enable-checking='yes,glyphs'でEmacsをconfigureすることにより、これが有効になります。"

#. type: Plain text
#: DEBUG.orig:499
msgid ""
"Building Emacs like that activates many assertions which scrutinize display "
"code operation more than Emacs does normally.  (To see the code which tests "
"these assertions, look for calls to the 'eassert' macros.)  Any assertion "
"that is reported to fail should be investigated."
msgstr "このようにEmacsをビルドすると、ディスプレイコード処理を検査する多くのassertionが、通常Emacsが行うより多く活性化されます(これらのassertionが何をテストしているかは、'eassert'マクロ呼び出しを確認してください)。失敗を報告するassertionは精査するべきです。"

#. type: Plain text
#: DEBUG.orig:502
msgid ""
"When you debug display problems running emacs under X, you can use the 'ff' "
"command to flush all pending display updates to the screen."
msgstr "X配下で実行中のEmacsにたいしてディスプレイの問題をデバッグするときは、'ff'コマンドを使用して、待機中のすべての画面表示の更新をflushできます。"

#. type: Plain text
#: DEBUG.orig:505
msgid ""
"The src/.gdbinit file defines many useful commands for dumping redisplay "
"related data structures in a terse and user-friendly format:"
msgstr "src/.gdbinitファイルでは、再表示関連のデータ構造を簡潔でユーザーフレンドリーなフォーマットでダンプするためのコマンドが多数定義されています:"

#. type: Plain text
#: DEBUG.orig:514
#, no-wrap
msgid ""
" 'ppt' prints value of PT, narrowing, and gap in current buffer.\n"
" 'pit' dumps the current display iterator 'it'.\n"
" 'pwin' dumps the current window 'win'.\n"
" 'prow' dumps the current glyph_row 'row'.\n"
" 'pg' dumps the current glyph 'glyph'.\n"
" 'pgi' dumps the next glyph.\n"
" 'pgrow' dumps all glyphs in current glyph_row 'row'.\n"
" 'pcursor' dumps current output_cursor.\n"
msgstr ""
" 'ppt' カレントバッファーのPT値(ポイント値)、ナロー、ギャップをプリント。\n"
" 'pit' カレントディスプレイイテレータ'it'をダンプ。\n"
" 'pwin' カレントウィンドウ'win'をダンプ。\n"
" 'prow' カレントグリフ行glyph_row 'row'をダンプ。\n"
" 'pg' カレントグリフ'glyph'をダンプ。\n"
" 'pgi' 次のグリフをダンプ。\n"
" 'pgrow' カレントグリフ行glyph_row 'row'内のすべてのグリフをダンプ。\n"
" 'pcursor' カレント出力カーソルoutput_cursorをダンプ。\n"

#. type: Plain text
#: DEBUG.orig:518
msgid ""
"The above commands also exist in a version with an 'x' suffix which takes an "
"object of the relevant type as argument.  For example, 'pgrowx' dumps all "
"glyphs in its argument, which must be of type 'struct glyph_row'."
msgstr "上記のコマンドには関連する型のオブジェクトを引数とする、サフィックス'x'のついたバージョンも存在します。たとえば、'pgrowx'は引数内のすべてのグリフをダンプします。引数の型は'struct glyph_row'でなければなりません。"

#. type: Plain text
#: DEBUG.orig:522
msgid ""
"Since redisplay is performed by Emacs very frequently, you need to place "
"your breakpoints cleverly to avoid hitting them all the time, when the issue "
"you are debugging did not (yet) happen.  Here are some useful techniques for "
"that:"
msgstr "再表示はEmacsにより非常に頻繁に行われるので、デバッグ中の問題が(まだ)発生していないのに、再表示のたびに毎回ブレークしてしまうのを避けるため、ブレークポイントを巧妙に配す必要があります。これに関する有用なテクニックを以下に挙げます:"

#. type: Plain text
#: DEBUG.orig:528
#, no-wrap
msgid ""
" . Put a breakpoint at 'Fredraw_display' before running Emacs.  Then do\n"
"   whatever is required to reproduce the bad display, and invoke \"M-x\n"
"   redraw-display\".  The debugger will kick in, and you can set or enable\n"
"   breakpoints in strategic places, knowing that the bad display will be\n"
"   redrawn from scratch.\n"
msgstr " . Emacsを実行する前に'Fredraw_display'にブレークポイントを置きます。その後で誤った表示が再現するのに必要な何かを行い、\"M-x redraw-display\"を呼び出してください。するとブレークによりデバッグに制御が渡ります。誤った表示がスクラッチから再描画されるのが解るので、戦略的な場所にブレークポイントをセットしたり有効にできます。\n"

#. type: Plain text
#: DEBUG.orig:536
#, no-wrap
msgid ""
" . For debugging incorrect cursor position, a good place to put a breakpoint "
"is\n"
"   in 'set_cursor_from_row'.  The first time this function is called as part "
"of\n"
"   'redraw-display', Emacs is redrawing the minibuffer window, which is "
"usually\n"
"   not what you want; type \"continue\" to get to the call you want.  In "
"general,\n"
"   always make sure 'set_cursor_from_row' is called for the right window "
"and\n"
"   buffer by examining the value of w->contents: it should be the buffer "
"whose\n"
"   display you are debugging.\n"
msgstr ". 間違ったカーソル位置をデバッグする場合は、ブレークポイントを置くのに適した場所は'set_cursor_from_row'です。この関数は最初、'redraw-display'の一部として呼び出されます。これはEmacsがミニバッファーを再描画するためで、通常これはあなたが望むものではないでしょう。そこで\"continue\"をタイプしてあなたが望む呼び出しを取得します。一般的には、w->contentsの値を検査して、常に'set_cursor_from_row'が正しいウィンドウとバッファーにたいして呼び出されているか検証してください。それはデバッグ中に表示されているバッファーであるべきです。\n"

#. type: Plain text
#: DEBUG.orig:542
#, no-wrap
msgid ""
" . 'set_cursor_from_row' is also a good place to look at the contents of a\n"
"   screen line (a.k.a. \"glyph row\"), by means of the 'pgrow' GDB command.  "
"Of\n"
"   course, you need first to make sure the cursor is on the screen line "
"which\n"
"   you want to investigate.  If you have set a breakpoint in "
"'Fredraw_display',\n"
"   as advised above, move cursor to that line before invoking "
"'redraw-display'.\n"
msgstr " . スクリーン行(別名はグリフ行)の内容をGDBコマンド'pgrow'で調べるのにもset_cursor_from_row'は適した場所です。もちろん最初に調査したいスクリーン行にカーソルがあるか確認する必要があります。上記のアドバイスにしたがい'Fredraw_display'にブレークポイントをセットした場合は、'redraw-display'を呼び出す前にその行にカーソルを移動してください。\n"

#. type: Plain text
#: DEBUG.orig:550
#, no-wrap
msgid ""
" . If the problem happens only at some specific buffer position or for "
"some\n"
"   specific rarely-used character, you can make your breakpoints conditional "
"on\n"
"   those values.  The display engine maintains the buffer and string "
"position\n"
"   it is processing in the it->current member; for example, the buffer\n"
"   character position is in it->current.pos.charpos.  Most redisplay "
"functions\n"
"   accept a pointer to a 'struct it' object as their argument, so you can "
"make\n"
"   conditional breakpoints in those functions, like this:\n"
msgstr " . 特定のバッファー位置や稀にしか使用されない特定の文字だけで問題が発生する場合は、ブレークポイント条件をそれらの値にすることができます。ディスプレイエンジンはバッファーと文字列位置を保守しており、それはit->currentメンバーを処理します。たとえば、バッファーの文字位置はit->current.pos.charposの中です。ほとんどの再表示関数は引数に'struct it'オブジェクトを受け取るので、以下のようにそれらの関数内に条件つきブレークポイントをセットできます:\n"

#. type: Plain text
#: DEBUG.orig:552
#, no-wrap
msgid "    (gdb) break x_produce_glyphs if it->current.pos.charpos == 1234\n"
msgstr "    (gdb) break x_produce_glyphs if it->current.pos.charpos == 1234\n"

#. type: Plain text
#: DEBUG.orig:555
#, no-wrap
msgid ""
"   For conditioning on the character being displayed, use it->c or\n"
"   it->char_to_display.\n"
msgstr "   表示される文字にたいする条件には、it->cまたはit->char_to_displayを使用してください。\n"

#. type: Plain text
#: DEBUG.orig:562
#, no-wrap
msgid ""
" . You can also make the breakpoints conditional on what object is being "
"used\n"
"   for producing glyphs for display.  The it->method member has the value\n"
"   GET_FROM_BUFFER for displaying buffer contents, GET_FROM_STRING for\n"
"   displaying a Lisp string (e.g., a 'display' property or an overlay "
"string),\n"
"   GET_FROM_IMAGE for displaying an image, etc.  See 'enum it_method' in\n"
"   dispextern.h for the full list of values.\n"
msgstr " . 表示のためのグリフ生成に使用されるオブジェクトの種類にたいしてブレークポイント条件をセットすることもできます。it->methodメンバーの値がGET_FROM_BUFFERならバッファー内容の表示、GET_FROM_STRINGならLisp文字列(たとえば'display'プロパティやオーバーレイ文字列)の表示、GET_FROM_IMAGEならイメージの表示、...です。この値の完全なリストは、dispextern.h内の'enum it_method'を確認してください。\n"

#. type: Plain text
#: DEBUG.orig:564
#, no-wrap
msgid "** Following longjmp call.\n"
msgstr "** longjmp呼び出しの追跡。\n"

#. type: Plain text
#: DEBUG.orig:569
msgid ""
"Recent versions of glibc (2.4+?) encrypt stored values for setjmp/longjmp "
"which prevents GDB from being able to follow a longjmp call using 'next'.  "
"To disable this protection you need to set the environment variable "
"LD_POINTER_GUARD to 0."
msgstr "最新バージョンのglibc(2.4+?)は、GDBの'next'使用によるlongjmp呼び出しの追跡を防ぐため、setjmp/longjmpにたいする値を暗号化して格納します。この保護を無効にするためには、環境変数LD_POINTER_GUARDに0をセットする必要があります。"

#. type: Plain text
#: DEBUG.orig:571
#, no-wrap
msgid "** Using GDB in Emacs\n"
msgstr "** Emacs内でのGDBの使用\n"

#. type: Plain text
#: DEBUG.orig:575
msgid ""
"Debugging with GDB in Emacs offers some advantages over the command line "
"(See the GDB Graphical Interface node of the Emacs manual).  There are also "
"some features available just for debugging Emacs:"
msgstr "Emacs内でのGDBによるデバッグには、コマンドラインでのデバッグにたいしていくつかの利点があります(EmacsマニュアルのGDB Graphical Interfaceノードを参照)。Emacsでのデバッグだけで利用できる機能もいくつかあります:"

#. type: Bullet: '1) '
#: DEBUG.orig:579
msgid ""
"The command gud-print is available on the tool bar (the 'p' icon) and allows "
"the user to print the s-expression of the variable at point, in the GUD "
"buffer."
msgstr "ツールバー('p'アイコン)からコマンドgud-printが利用でき、GUDバッファーではポイント位置の変数のS式をプリントできます。"

#. type: Bullet: '2) '
#: DEBUG.orig:582
msgid ""
"Pressing 'p' on a component of a watch expression that is a lisp object in "
"the speedbar prints its s-expression in the GUD buffer."
msgstr "スピードバーのwatch式のコンポーネント(Lispオブジェクト)で'p'を押下すると、GUDバッファーにそのLispオブジェクトのS式がプリントされます。"

#. type: Bullet: '3) '
#: DEBUG.orig:586
msgid ""
"The STOP button on the tool bar and the Signals->STOP menu-bar menu item are "
"adjusted so that they send SIGTSTP instead of the usual SIGINT."
msgstr "ツールバーのSTOPボタンとメニューバーのメニューアイテムSignals->STOPは調整済みなので、通常のSIGINTのかわりにSIGTSTPが送られます。"

#. type: Bullet: '4) '
#: DEBUG.orig:589
msgid ""
"The command gud-pv has the global binding 'C-x C-a C-v' and prints the value "
"of the lisp variable at point."
msgstr "ポイント位置のLisp変数の値をプリントするコマンドgud-pvは、'C-x C-a C-v'にグローバルにバインドされます。"

#. type: Plain text
#: DEBUG.orig:591
#, no-wrap
msgid "** Debugging what happens while preloading and dumping Emacs\n"
msgstr "** preloadやEmacsのダンプ中に何が起こっているかデバッグする\n"

#. type: Plain text
#: DEBUG.orig:595
msgid ""
"Debugging 'temacs' is useful when you want to establish whether a problem "
"happens in an undumped Emacs.  To run 'temacs' under a debugger, type \"gdb "
"temacs\", then start it with 'r -batch -l loadup'."
msgstr "ダンプされていないEmacsで発生する問題なのか確証を得たい場合は、'temacs'をデバッグするのが役立ちます。デバッガ配下で'temacs'を実行するには、\"gdb temacs\"とタイプしてから'r -batch -l loadup'で開始します。"

#. type: Plain text
#: DEBUG.orig:599
msgid ""
"If you need to debug what happens during dumping, start it with 'r -batch -l "
"loadup dump' instead.  For debugging the bootstrap dumping, use \"loadup "
"bootstrap\" instead of \"loadup dump\"."
msgstr "ダンプ中に何が起こっているかデバッグする必要がある場合は、かわりに'r -batch -l loadup dump'で開始します。bootstrapのダンプのデバッグには、\"loadup dump\"のかわりに\"loadup bootstrap\"を使用してください。"

#. type: Plain text
#: DEBUG.orig:603
msgid ""
"If temacs actually succeeds when running under GDB in this way, do not try "
"to run the dumped Emacs, because it was dumped with the GDB breakpoints in "
"it."
msgstr "この方法によりGDB配下でtemacsの実行に実際に成功した場合は、ダンプされたEmacsの実行を試みないでください。なぜならそれはGDBのブレークポイントがセットされた状態でダンプされているからです。"

#. type: Plain text
#: DEBUG.orig:605
#, no-wrap
msgid "** If you encounter X protocol errors\n"
msgstr "** Xプロトコルエラーに遭遇したシェル\n"

#. type: Plain text
#: DEBUG.orig:609
msgid ""
"The X server normally reports protocol errors asynchronously, so you find "
"out about them long after the primitive which caused the error has returned."
msgstr "Xサーバーは通常、プロトコルエラーを非同期で報告するので、エラーがリターンされる原因の根本よりかなり後にそれらの見つけることになります。"

#. type: Plain text
#: DEBUG.orig:615
msgid ""
"To get clear information about the cause of an error, try evaluating "
"(x-synchronize t).  That puts Emacs into synchronous mode, where each Xlib "
"call checks for errors before it returns.  This mode is much slower, but "
"when you get an error, you will see exactly which call really caused the "
"error."
msgstr "エラー原因についての明快な情報を入手するために、(x-synchronize t)を評価してみてください。これはEmacsを同期モードにして、それぞれのXlib呼び出しにたいしてリターン前にエラーをチェックします。このモードはかなり低速ですが、エラーが発生したとき、どの呼び出しがエラーを発生させたか正確に確認できるでしょう。"

#. type: Plain text
#: DEBUG.orig:618
msgid ""
"You can start Emacs in a synchronous mode by invoking it with the -xrm "
"option, like this:"
msgstr "以下のように-xrmオプションとともに呼び出すことにより、同期モードでEmacsを開始できます:"

#. type: Plain text
#: DEBUG.orig:620
#, no-wrap
msgid "    emacs -xrm \"emacs.synchronous: true\"\n"
msgstr "    emacs -xrm \"emacs.synchronous: true\"\n"

#. type: Plain text
#: DEBUG.orig:624
msgid ""
"Setting a breakpoint in the function 'x_error_quitter' and looking at the "
"backtrace when Emacs stops inside that function will show what code causes "
"the X protocol errors."
msgstr "関数'x_error_quitter'内にブレークポイントをセットして、Emacsがストップしたときにその関数内のバックトレースを調べれば、Xプロトコルエラーの原因となったコードを確認できるでしょう。"

#. type: Plain text
#: DEBUG.orig:628
msgid ""
"Some bugs related to the X protocol disappear when Emacs runs in a "
"synchronous mode.  To track down those bugs, we suggest the following "
"procedure:"
msgstr "同期モードでEmacsが実行中のときは発生しないXプロトコル関連のエラーもいくつかあります。これらのバグを追跡するために、以下の手順を提案します:"

#. type: Bullet: '  - '
#: DEBUG.orig:633
msgid ""
"Run Emacs under a debugger and put a breakpoint inside the primitive "
"function which, when called from Lisp, triggers the X protocol errors.  For "
"example, if the errors happen when you delete a frame, put a breakpoint "
"inside 'Fdelete_frame'."
msgstr "デバッガ配下でEmacsを実行して、Lisp関数から呼び出されたときXプロトコルエラーを発生するプリミティブ関数の中にブレークポイントを置きます。たとえばフレームを削除したときエラーが発生する場合は、'Fdelete_frame'の中にブレークポイントを置いてください。"

#. type: Bullet: '  - '
#: DEBUG.orig:637
msgid ""
"When the breakpoint breaks, step through the code, looking for calls to X "
"functions (the ones whose names begin with \"X\" or \"Xt\" or \"Xm\")."
msgstr "ブレークポイントでブレークしたとき、コードをステップ実行してX関数(\"X\"、\"Xt\"、\"Xm\"で始まる関数)の呼び出しを探してください。"

#. type: Bullet: '  - '
#: DEBUG.orig:640
msgid ""
"Insert calls to 'XSync' before and after each call to the X functions, like "
"this:"
msgstr "以下のように、それぞれのX関数呼び出しの前後に'XSync'呼び出しを挿入します。"

#. type: Plain text
#: DEBUG.orig:642
#, no-wrap
msgid "       XSync (f->output_data.x->display_info->display, 0);\n"
msgstr "       XSync (f->output_data.x->display_info->display, 0);\n"

#. type: Plain text
#: DEBUG.orig:648
#, no-wrap
msgid ""
"    where 'f' is the pointer to the 'struct frame' of the selected\n"
"    frame, normally available via XFRAME (selected_frame).  (Most\n"
"    functions which call X already have some variable that holds the\n"
"    pointer to the frame, perhaps called 'f' or 'sf', so you shouldn't\n"
"    need to compute it.)\n"
msgstr "    ここで'f'は選択されたフレームの'struct frame'で、通常はXFRAME(selected_frame)を通じて利用できます(Xを呼び出すほとんどの関数はフレームへのポインターを保持するために、もしかしたら'f'や'sf'と呼ばれる変数をすでにもっているので、その場合はそれを計算する必要はありません)。\n"

#. type: Plain text
#: DEBUG.orig:652
#, no-wrap
msgid ""
"    If your debugger can call functions in the program being debugged,\n"
"    you should be able to issue the calls to 'XSync' without recompiling\n"
"    Emacs.  For example, with GDB, just type:\n"
msgstr "    あなたのデバッガがデバッガ中のプログラム内の関数を呼び出せる場合は、Emacsをリコンパイルせずに'XSync'を呼び出せて然るべきです。GDBでは単に:\n"

#. type: Plain text
#: DEBUG.orig:654
#, no-wrap
msgid "       call XSync (f->output_data.x->display_info->display, 0)\n"
msgstr "       call XSync (f->output_data.x->display_info->display, 0)\n"

#. type: Plain text
#: DEBUG.orig:658
#, no-wrap
msgid ""
"    before and immediately after the suspect X calls.  If your\n"
"    debugger does not support this, you will need to add these pairs\n"
"    of calls in the source and rebuild Emacs.\n"
msgstr "    これを疑わしいX呼び出しの前後でタイプするだけです。デバッガがこれをサポートしなければ、これらの呼び出しの組をソースに追加して、Emacsをリビルドする必要があるでしょう。\n"

#. type: Plain text
#: DEBUG.orig:664
#, no-wrap
msgid ""
"    Either way, systematically step through the code and issue these\n"
"    calls until you find the first X function called by Emacs after\n"
"    which a call to 'XSync' winds up in the function\n"
"    'x_error_quitter'.  The first X function call for which this\n"
"    happens is the one that generated the X protocol error.\n"
msgstr "    どちらの方法でも、'XSync'の後に'x_error_quitter'関数に遷移するようなEmacsに呼び出される最初のX関数が見つかるまで、体系的にコードをステップ実行してこれらの呼び出しを行います。これが発生する最初のX関数呼び出しがXプロトコルエラーを発生しています。\n"

#. type: Bullet: '  - '
#: DEBUG.orig:667
msgid ""
"You should now look around this offending X call and try to figure out what "
"is wrong with it."
msgstr "これであなたは目障りなX呼び出しを見つけ出して、何が悪いのか解決を試みることができます。"

#. type: Plain text
#: DEBUG.orig:669
#, no-wrap
msgid "** If Emacs causes errors or memory leaks in your X server\n"
msgstr "** EmacsがXサーバー内でエラーやメモリーリークを起こす場合\n"

#. type: Plain text
#: DEBUG.orig:672
msgid ""
"You can trace the traffic between Emacs and your X server with a tool like "
"xmon, available at ftp://ftp.x.org/contrib/devel_tools/."
msgstr "xmon(ftp://ftp.x.org/contrib/devel_tools/から入手可能)のようなツールで、EmacsとXサーバー間のトラフィックをトレースできます。"

#. type: Plain text
#: DEBUG.orig:680
msgid ""
"Xmon can be used to see exactly what Emacs sends when X protocol errors "
"happen.  If Emacs causes the X server memory usage to increase you can use "
"xmon to see what items Emacs creates in the server (windows, graphical "
"contexts, pixmaps) and what items Emacs delete.  If there are consistently "
"more creations than deletions, the type of item and the activity you do when "
"the items get created can give a hint where to start debugging."
msgstr "xmonはXプロトコルエラー発生時にEmacsが何を送信したのか正確に知るために使用できます。EmacsがXサーバーのメモリー使用を増大させている場合は、Xサーバー内にEmacsがどんなアイテム(windows、graphical contexts、pixmaps)を作成、または削除したかをxmonを使用して確認できます。もし終始一貫して削除より作成が多い場合は、そのアイテムの型とそのアイテムが作成されるとき行っていたアクティビティが、デバッグ開始のヒントになり得ます。"

#. type: Plain text
#: DEBUG.orig:682
#, no-wrap
msgid "** If the symptom of the bug is that Emacs fails to respond\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:690
msgid ""
"Don't assume Emacs is 'hung'--it may instead be in an infinite loop.  To "
"find out which, make the problem happen under GDB and stop Emacs once it is "
"not responding.  (If Emacs is using X Windows directly, you can stop Emacs "
"by typing C-z at the GDB job.  On MS-Windows, run Emacs as usual, and then "
"attach GDB to it -- that will usually interrupt whatever Emacs is doing and "
"let you perform the steps described below.)"
msgstr ""

#. type: Plain text
#: DEBUG.orig:693
msgid ""
"Then try stepping with 'step'.  If Emacs is hung, the 'step' command won't "
"return.  If it is looping, 'step' will return."
msgstr ""

#. type: Plain text
#: DEBUG.orig:698
msgid ""
"If this shows Emacs is hung in a system call, stop it again and examine the "
"arguments of the call.  If you report the bug, it is very important to state "
"exactly where in the source the system call is, and what the arguments are."
msgstr ""

#. type: Plain text
#: DEBUG.orig:705
msgid ""
"If Emacs is in an infinite loop, try to determine where the loop starts and "
"ends.  The easiest way to do this is to use the GDB command 'finish'.  Each "
"time you use it, Emacs resumes execution until it exits one stack frame.  "
"Keep typing 'finish' until it doesn't return--that means the infinite loop "
"is in the stack frame which you just tried to finish."
msgstr ""

#. type: Plain text
#: DEBUG.orig:711
msgid ""
"Stop Emacs again, and use 'finish' repeatedly again until you get back to "
"that frame.  Then use 'next' to step through that frame.  By stepping, you "
"will see where the loop starts and ends.  Also, examine the data being used "
"in the loop and try to determine why the loop does not exit when it should."
msgstr ""

#. type: Plain text
#: DEBUG.orig:718
msgid ""
"On GNU and Unix systems, you can also trying sending Emacs SIGUSR2, which, "
"if 'debug-on-event' has its default value, will cause Emacs to attempt to "
"break it out of its current loop and into the Lisp debugger.  (See the node "
"\"Debugging\" in the ELisp manual for the details about the Lisp debugger.)  "
"This feature is useful when a C-level debugger is not conveniently "
"available."
msgstr ""

#. type: Plain text
#: DEBUG.orig:721
#, no-wrap
msgid ""
"** If certain operations in Emacs are slower than they used to be, here\n"
"is some advice for how to find out why.\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:725
msgid ""
"Stop Emacs repeatedly during the slow operation, and make a backtrace each "
"time.  Compare the backtraces looking for a pattern--a specific function "
"that shows up more often than you'd expect."
msgstr ""

#. type: Plain text
#: DEBUG.orig:729
msgid ""
"If you don't see a pattern in the C backtraces, get some Lisp backtrace "
"information by typing \"xbacktrace\" or by looking at Ffuncall frames (see "
"above), and again look for a pattern."
msgstr ""

#. type: Plain text
#: DEBUG.orig:733
msgid ""
"When using X, you can stop Emacs at any time by typing C-z at GDB.  When not "
"using X, you can do this with C-g.  On non-Unix platforms, such as MS-DOS, "
"you might need to press C-BREAK instead."
msgstr ""

#. type: Plain text
#: DEBUG.orig:735
#, no-wrap
msgid "** If GDB does not run and your debuggers can't load Emacs.\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:740
msgid ""
"On some systems, no debugger can load Emacs with a symbol table, perhaps "
"because they all have fixed limits on the number of symbols and Emacs "
"exceeds the limits.  Here is a method that can be used in such an "
"extremity.  Do"
msgstr ""

#. type: Plain text
#: DEBUG.orig:749
#, no-wrap
msgid ""
"    nm -n temacs > nmout\n"
"    strip temacs\n"
"    adb temacs\n"
"    0xd:i\n"
"    0xe:i\n"
"    14:i\n"
"    17:i\n"
"    :r -l loadup   (or whatever)\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:752
msgid ""
"It is necessary to refer to the file 'nmout' to convert numeric addresses "
"into symbols and vice versa."
msgstr ""

#. type: Plain text
#: DEBUG.orig:757
msgid ""
"It is useful to be running under a window system.  Then, if Emacs becomes "
"hopelessly wedged, you can create another window to do kill -9 in.  kill "
"-ILL is often useful too, since that may make Emacs dump core or return to "
"adb."
msgstr ""

#. type: Plain text
#: DEBUG.orig:759
#, no-wrap
msgid "** Debugging incorrect screen updating on a text terminal.\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:763
msgid ""
"To debug Emacs problems that update the screen wrong, it is useful to have a "
"record of what input you typed and what Emacs sent to the screen.  To make "
"these records, do"
msgstr ""

#. type: Plain text
#: DEBUG.orig:766
msgid "(open-dribble-file \"~/.dribble\")  (open-termscript \"~/.termscript\")"
msgstr ""

#. type: Plain text
#: DEBUG.orig:771
msgid ""
"The dribble file contains all characters read by Emacs from the terminal, "
"and the termscript file contains all characters it sent to the terminal.  "
"The use of the directory '~/' prevents interference with any other user."
msgstr ""

#. type: Plain text
#: DEBUG.orig:776
msgid ""
"If you have irreproducible display problems, put those two expressions in "
"your ~/.emacs file.  When the problem happens, exit the Emacs that you were "
"running, kill it, and rename the two files.  Then you can start another "
"Emacs without clobbering those files, and use it to examine them."
msgstr ""

#. type: Plain text
#: DEBUG.orig:781
msgid ""
"An easy way to see if too much text is being redrawn on a terminal is to "
"evaluate '(setq inverse-video t)' before you try the operation you think "
"will cause too much redrawing.  This doesn't refresh the screen, so only "
"newly drawn text is in inverse video."
msgstr ""

#. type: Plain text
#: DEBUG.orig:783
#, no-wrap
msgid "** Debugging LessTif\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:789
msgid ""
"If you encounter bugs whereby Emacs built with LessTif grabs all mouse and "
"keyboard events, or LessTif menus behave weirdly, it might be helpful to set "
"the 'DEBUGSOURCES' and 'DEBUG_FILE' environment variables, so that one can "
"see what LessTif was doing at this point.  For instance"
msgstr ""

#. type: Plain text
#: DEBUG.orig:793
#, no-wrap
msgid ""
"  export DEBUGSOURCES=\"RowColumn.c:MenuShell.c:MenuUtil.c\"\n"
"  export DEBUG_FILE=/usr/tmp/LESSTIF_TRACE\n"
"  emacs &\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:798
msgid ""
"causes LessTif to print traces from the three named source files to a file "
"in '/usr/tmp' (that file can get pretty large).  The above should be typed "
"at the shell prompt before invoking Emacs, as shown by the last line above."
msgstr ""

#. type: Plain text
#: DEBUG.orig:803
msgid ""
"Running GDB from another terminal could also help with such problems.  You "
"can arrange for GDB to run on one machine, with the Emacs display appearing "
"on another.  Then, when the bug happens, you can go back to the machine "
"where you started GDB and use the debugger from there."
msgstr ""

#. type: Plain text
#: DEBUG.orig:805
#, no-wrap
msgid "** Debugging problems which happen in GC\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:813
msgid ""
"The array 'last_marked' (defined on alloc.c) can be used to display up to "
"500 last objects marked by the garbage collection process.  Whenever the "
"garbage collector marks a Lisp object, it records the pointer to that object "
"in the 'last_marked' array, which is maintained as a circular buffer.  The "
"variable 'last_marked_index' holds the index into the 'last_marked' array "
"one place beyond where the pointer to the very last marked object is stored."
msgstr ""

#. type: Plain text
#: DEBUG.orig:819
msgid ""
"The single most important goal in debugging GC problems is to find the Lisp "
"data structure that got corrupted.  This is not easy since GC changes the "
"tag bits and relocates strings which make it hard to look at Lisp objects "
"with commands such as 'pr'.  It is sometimes necessary to convert "
"Lisp_Object variables into pointers to C struct's manually."
msgstr ""

#. type: Plain text
#: DEBUG.orig:836
msgid ""
"Use the 'last_marked' array and the source to reconstruct the sequence that "
"objects were marked.  In general, you need to correlate the values recorded "
"in the 'last_marked' array with the corresponding stack frames in the "
"backtrace, beginning with the innermost frame.  Some subroutines of "
"'mark_object' are invoked recursively, others loop over portions of the data "
"structure and mark them as they go.  By looking at the code of those "
"routines and comparing the frames in the backtrace with the values in "
"'last_marked', you will be able to find connections between the values in "
"'last_marked'.  E.g., when GC finds a cons cell, it recursively marks its "
"car and its cdr.  Similar things happen with properties of symbols, elements "
"of vectors, etc.  Use these connections to reconstruct the data structure "
"that was being marked, paying special attention to the strings and names of "
"symbols that you encounter: these strings and symbol names can be used to "
"grep the sources to find out what high-level symbols and global variables "
"are involved in the crash."
msgstr ""

#. type: Plain text
#: DEBUG.orig:843
msgid ""
"Once you discover the corrupted Lisp object or data structure, grep the "
"sources for its uses and try to figure out what could cause the corruption.  "
"If looking at the sources doesn't help, you could try setting a watchpoint "
"on the corrupted data, and see what code modifies it in some invalid way.  "
"(Obviously, this technique is only useful for data that is modified only "
"very rarely.)"
msgstr ""

#. type: Plain text
#: DEBUG.orig:847
msgid ""
"It is also useful to look at the corrupted object or data structure in a "
"fresh Emacs session and compare its contents with a session that you are "
"debugging."
msgstr ""

#. type: Plain text
#: DEBUG.orig:849
#, no-wrap
msgid "** Debugging problems with non-ASCII characters\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:856
msgid ""
"If you experience problems which seem to be related to non-ASCII characters, "
"such as \\201 characters appearing in the buffer or in your files, set the "
"variable byte-debug-flag to t.  This causes Emacs to do some extra checks, "
"such as look for broken relations between byte and character positions in "
"buffers and strings; the resulting diagnostics might pinpoint the cause of "
"the problem."
msgstr ""

#. type: Plain text
#: DEBUG.orig:858
#, no-wrap
msgid "** Debugging the TTY (non-windowed) version\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:862
msgid ""
"The most convenient method of debugging the character-terminal display is to "
"do that on a window system such as X.  Begin by starting an xterm window, "
"then type these commands inside that window:"
msgstr ""

#. type: Plain text
#: DEBUG.orig:865
#, no-wrap
msgid ""
"  $ tty\n"
"  $ echo $TERM\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:867
msgid "Let's say these commands print \"/dev/ttyp4\" and \"xterm\", respectively."
msgstr ""

#. type: Plain text
#: DEBUG.orig:871
msgid ""
"Now start Emacs (the normal, windowed-display session, i.e. without the "
"'-nw' option), and invoke \"M-x gdb RET emacs RET\" from there.  Now type "
"these commands at GDB's prompt:"
msgstr ""

#. type: Plain text
#: DEBUG.orig:875
#, no-wrap
msgid ""
"  (gdb) set args -nw -t /dev/ttyp4\n"
"  (gdb) set environment TERM xterm\n"
"  (gdb) run\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:878
msgid ""
"The debugged Emacs should now start in no-window mode with its display "
"directed to the xterm window you opened above."
msgstr ""

#. type: Plain text
#: DEBUG.orig:881
msgid ""
"Similar arrangement is possible on a character terminal by using the "
"'screen' package."
msgstr ""

#. type: Plain text
#: DEBUG.orig:884
msgid ""
"On MS-Windows, you can start Emacs in its own separate console by setting "
"the new-console option before running Emacs under GDB:"
msgstr ""

#. type: Plain text
#: DEBUG.orig:889
#, no-wrap
msgid "** Running Emacs built with malloc debugging packages\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:894
msgid ""
"If Emacs exhibits bugs that seem to be related to use of memory allocated "
"off the heap, it might be useful to link Emacs with a special debugging "
"library, such as Electric Fence (a.k.a. efence) or GNU Checker, which helps "
"find such problems."
msgstr ""

#. type: Plain text
#: DEBUG.orig:900
msgid ""
"Emacs compiled with such packages might not run without some hacking, "
"because Emacs replaces the system's memory allocation functions with its own "
"versions, and because the dumping process might be incompatible with the way "
"these packages use to track allocated memory.  Here are some of the changes "
"you might find necessary:"
msgstr ""

#. type: Bullet: '  - '
#: DEBUG.orig:902
msgid "Edit configure, to set system_malloc and CANNOT_DUMP to \"yes\"."
msgstr ""

#. type: Bullet: '  - '
#: DEBUG.orig:906
msgid ""
"Configure with a different --prefix= option.  If you use GCC, version 2.7.2 "
"is preferred, as some malloc debugging packages work a lot better with it "
"than with 2.95 or later versions."
msgstr ""

#. type: Bullet: '  - '
#: DEBUG.orig:908
msgid "Type \"make\" then \"make -k install\"."
msgstr ""

#. type: Bullet: '  - '
#: DEBUG.orig:911
msgid ""
"If required, invoke the package-specific command to prepare src/temacs for "
"execution."
msgstr ""

#. type: Bullet: '  - '
#: DEBUG.orig:913
msgid "cd ..; src/temacs"
msgstr ""

#. type: Plain text
#: DEBUG.orig:916
msgid ""
"(Note that this runs 'temacs' instead of the usual 'emacs' executable.  This "
"avoids problems with dumping Emacs mentioned above.)"
msgstr ""

#. type: Plain text
#: DEBUG.orig:923
msgid ""
"Some malloc debugging libraries might print lots of false alarms for "
"bitfields used by Emacs in some data structures.  If you want to get rid of "
"the false alarms, you will have to hack the definitions of these data "
"structures on the respective headers to remove the ':N' bitfield definitions "
"(which will cause each such field to use a full int)."
msgstr ""

#. type: Plain text
#: DEBUG.orig:925
#, no-wrap
msgid "** How to recover buffer contents from an Emacs core dump file\n"
msgstr ""

#. type: Plain text
#: DEBUG.orig:930
msgid ""
"The file etc/emacs-buffer.gdb defines a set of GDB commands for recovering "
"the contents of Emacs buffers from a core dump file.  You might also find "
"those commands useful for displaying the list of buffers in human-readable "
"format from within the debugger."
msgstr ""

#. type: Plain text
#: DEBUG.orig:933
msgid "This file is part of GNU Emacs."
msgstr ""

#. type: Plain text
#: DEBUG.orig:938
msgid ""
"GNU Emacs is free software: you can redistribute it and/or modify it under "
"the terms of the GNU General Public License as published by the Free "
"Software Foundation, either version 3 of the License, or (at your option) "
"any later version."
msgstr ""

#. type: Plain text
#: DEBUG.orig:943
msgid ""
"GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY "
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS "
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more "
"details."
msgstr ""

#. type: Plain text
#: DEBUG.orig:946
msgid ""
"You should have received a copy of the GNU General Public License along with "
"GNU Emacs.  If not, see <http://www.gnu.org/licenses/>."
msgstr ""

#. type: Plain text
#: DEBUG.orig:951
msgid "Local variables: mode: outline paragraph-separate: \"[ \t]*$\" end:"
msgstr ""
"Local variables:\n"
"mode: org\n"
"paragraph-separate: \"[ \t\f]*$\"\n"
"end:"
