GNU Emacsのデバッグ

Copyright (C) 1985, 2000-2017 Free Software Foundation, Inc.  See the end of
the file for license conditions.

** Preliminaries

このセクションは、あなたがすでにdebug情報つきEmacsのビルドや、GDBの設定と開始、GDBによる簡単なデバッグテクニックに親しんでいる場合はスキップできます。

*** Configuring Emacs for debugging

デバッグを簡単にするには、特別なオプションでEmacsをconfigureしてビルドするのが最善です。以下はわたしたちが推奨するconfigure時のオプションです(これらのオプションは、--prefixのようなあなたが必要とするかもしれない他のオプションに追加します)。

  CFLAGS='-O0 -g3' ./configure --enable-checking='yes,glyphs'
--enable-check-lisp-object-type

CFLAGSの値は重要です。なぜなら最適化されたコードのデバッグはとても困難だからです。(最適化されたコードでのみ問題が発生する場合は、最適化を有効にする必要があるかもしれません。このような場合は-O2のかわりにまず-Ogの使用を試みてください。-Ogはある種のコードのデバッグを極めて困難にするいくつかの最適化を無効にします。)

GCCのモダンなバージョンはコンパイラースイッチに-g3を使用するだけで利用できる、より精緻なdebug情報をサポートします。-g3に加えて-gdwarf-4を、それが失敗するようなら-gdwarf-3を試してみてください。これは最適化されたコードをデバッグする必要がある場合、とても重要になります。これに関する追加情報は以下の"analyze
failed assertionsの検索"にあります。

2つの--enable-*スイッチはオプションです。これらはGDBによるデバッグに影響を与えませんが、デバッグしている問題をより早くcatchするかもしれない追加コードをassertion
violation形式でコンパイルします。--enable-checkingオプションは表示に関する問題をデバッグするのに有用な追加機能も有効にします。詳細は、以下の"Emacsの再表示に関する問題のデバッグ"を参照してください。

デバッグ用のEmacsをインストールする必要はありません。'src'ディレクトリーに作成されるバイナリーをデバッグできます。

*** Configuring GDB

GDBでEmacをデバッグするときは、Emacs実行形式が作成されたディレクトリー(Emacsソースツリー内の'src'ディレクトリー)から直接GDBを開始するべきです。このディレクトリーには、Emacsをデバッグするためのさまざまなユーザー定義コマンドを定義する、.gdbinitファイルがあります(これらのコマンドは以下の"Lispオブジェクトの値の調査"および"Emacsの再表示に関する問題のデバッグ"で説明されています)。

カレントバッファーでEmacsのCソースファイルのどれか1つをvisitしているときに、Emacsから"M-x
gdb"コマンド(以下参照)によりデバッガーを開始すると、'src'ディレクトリー内で自動的にGDBが開始されます。

GDBのいくつかのバージョンでは、デフォルトではGDBを呼び出したディレクトリー内の.gdbinitファイルを自動的にロードしません。このようなバージョンのGDBでは、GDBを開始したとき以下のような警告を目にするかもしれません:

  warning: File ".../src/.gdbinit" auto-loading has been declined by your
`auto-load safe-path' set to "$debugdir:$datadir/auto-load".

これを修正するには~/.gdbinitファイルに以下の行を追加するのが、もっとも簡単な方法です:

  add-auto-load-safe-path /path/to/emacs/src/.gdbinit

この問題を克服するための方法は他にもいくつかあり、それらはすべてGDBユーザーマニュアルの"Auto-loading safe
path"ノードで説明されています。それらでも効果がない場合は、無条件でGDB initファイルをロードするために、GDBプロンプトで"source
/path/to/.gdbinit RET"とタイプしてください。

*** Use the Emacs GDB UI front-end

わたしたちはEmacsが提供するGDB用のGUIフロントエンドの使用を推奨します。
We recommend using the GUI front-end for GDB provided by Emacs.
このフロントエンドは、"M-x gdb RET"とタイプしてGDBを開始できます。
With it, you can start GDB by typing
このコマンドはデバッグするデフォルトのバイナリーのファイル名を提案します。この提案されるデフォルトが、デバッグしたいEmacsバイナリーと異なる場合は、必要に応じてファイル名を変更してください。かわりに、すでに実行中のEmacsプロセスにデバッガをアタッチしたい場合は、ミニバッファーに表示されているGDBコマンドにそれを告げるように変更します:

   gdb -i=mi -p PID

ここでPIDはPosixホストでは'top'や'ps'のようなシステムユーティリティーで、MS-WindowsではTask
Managerで表示される、実行中EmacsのPID数値です。

一度デバッガが起動すると"M-x gdb-many-windows
RET"とタイプすることにより、GDBUIが提供する追加のウィンドウがオープンします(メニューバーの"Gud->GDB-MI->Display
Other
Windows"をクリックしてもオープンできる)。この時点では、オープンしたウィンドウが水平スクロールせずに内容を表示するのに十分なスペースがあるよう、フレームを十分に大きく(またはフルスクリーン)しておいてください。

ウィンドウ構成は後でコマンド"M-x gdb-restore-windows RET"、またはメニューバーの"Display Other
Windows"を選択解除すればリストアできます。

*** Setting initial breakpoints

Emacsを実行させる前に、デバッガしたいコードにブレークポイントをセットすべきときです。ブレークポイントをセットすればEmacsはそこでストップして、GDBに制御を渡せます。デバッグしたいコードが、ある稀な状況下で実行されるコードであったり、特定のEmacsコマンドを手動で呼び出したときだけ実行されるコードの場合は、そこにブレークポイントをセットしてEmacsを実行すれば、そのコマンドの呼び出し、またはそれらの稀な状況を再現することにより、ブレークポイントがトリガーされます。

それほど幸運でなく、問題となっているコードが非常に頻繁に実行される場合は、バグのある振る舞いが発生する条件までブレークポイントがトリガーされないようにする方法を見つける必要があります。これにたいする唯一の処方はありません。あなたはより創造的になるとともに、何が適切か判断するためにコードを学ぶ必要があるでしょう。以下に、これにたいする有用なトリックをいくつか挙げます:

  . Make your breakpoint conditional on certain buffer or string position.
For example:

      (gdb) break foo.c:1234 if PT >= 9876

  . Set a break point in some rarely called function, then create the
conditions for the bug, call that rare function, and when GDB gets control,
set the breakpoint in the buggy code, knowing that it will now be called
when the bug happens.

  . If the bug manifests itself as an error message, set a breakpoint in
Fsignal, and when it breaks, look at the backtrace to see what triggers the
error.

他の追加テクニックは、以下の"デバッガに制御を渡す"で説明されています。

これでデバッグセッションを開始する準備ができました。

新たなEmacsセッションを開始した場合は、*gud-emacs*バッファー内で"run"とタイプした後にコマンドライン引数(例
"-Q")を続けてからRETを押下します。

実行中のEmacsにデバッガをアタッチした場合は、*gud-emacs*バッファー内で"continue"とタイプしてからRETを押下します。

Lispオブジェクトをデバッガする間、多くの変数に出会うことでしょう。これらは整数値(configure時に"--enable-check-lisp-object-type"オプションを使用した場合は構造体)なので解釈が困難であり、とりわけ長いリストで表現されている場合は困難です。これらをLisp形式で表示するために、'pp'コマンドを使用できます。このコマンドは出力を標準エラーストリーム(GNU/Linuxシステムでは"M-x
redirect-debugging-output"を使用してファイルにリダイレクトできます)に表示します。これはデスクトップアイコンから呼び出された実行中のEmacsにGDBをアタッチした場合に、出力を確認できなかったり、出力がどこか不明な場所(デスクトップ環境のドキュメントをチェックしてください)に切り捨てられる危険があることを意味します。

Lispオブジェクトの表示に関する追加情報は、以下の"Lispオブジェクトの値の調査"で見つけることができます。

このドキュメントの残りの部分は、Emacsのデバッグにおいて特に有用なテクニックを説明します。初めてEmacsをデバッグしようとするときは全体をありのまま目を通しておいて、必要なときに特定の問題を参照するよう、わたしたちは提案します。

Good luck!

** When you are trying to analyze failed assertions or backtraces, it is
essential to compile Emacs with flags suitable for debugging.  With GCC 4.8
or later, you can invoke 'make' with CFLAGS="-Og -g3".  With older GCC or
non-GCC compilers, you can use CFLAGS="-O0 -g3".  With GCC and higher
optimization levels such as -O2, the -fno-omit-frame-pointer and
-fno-crossjumping options are often essential.  The latter prevents GCC from
using the same abort call for all assertions in a given function, rendering
the stack backtrace useless for identifying the specific failed assertion.
Some versions of GCC support recent versions of the DWARF standard for
debugging info, but default to older versions; for example, they could
support -gdwarf-4 compiler option (for DWARF v4), but default to version 2
of the DWARF standard.  For best results in debugging abilities, find out
the highest version of DWARF your GCC can support, and use the corresponding
-gdwarf-N switch instead of just -g (you will still need -g3, as in
"-gdwarf-4 -g3").

** It is a good idea to run Emacs under GDB (or some other suitable
debugger) *all the time*.  Then, when Emacs crashes, you will be able to
debug the live process, not just a core dump.  (This is especially important
on systems which don't support core files, and instead print just the
registers and some stack addresses.)

** If Emacs hangs, or seems to be stuck in some infinite loop, typing "kill
-TSTP PID", where PID is the Emacs process ID, will cause GDB to kick in,
provided that you run under GDB.

** Getting control to the debugger

デバッガにEmacsをロードした後で、それを実行する前に効果的な場所にブレークポイントをセットすることは、必要なときにデバッガに確実に制御をリターンさせるもっとも効果的な方法です。

'Fsignal'はブレークポイントを配すのに、とても役に立つ場所です。すべてのLispエラーはここを通過します。Lispデバッガを起動させるエラーだけに関心がある場合は、'maybe_call_debugger'にブレークポイントを置くのが役に立つでしょう。

デバッガに制御を渡す他のテクニックとして、稀に使用されるいくつかの関数にブレークポイントを配す方法があります。そのような便利な関数の1つがFredraw_displayで、これは"M-x
redraw-display RET"でインタラクティブに呼び出すことができます。

任意のタイミングでデバッガにリターンするために、保証された方法があるのも便利です。これはXを使用しているときは簡単です。GDBで対話中のウィンドウでC-zをタイプすれば、普通のプログラムと同様にEmacsもストップします。(これは実行中のEmacsにアタッチされたGDBでは機能しません。この場合はEmacsを起動したシェルのウィンドウでC-zとタイプするか、以下で説明している"kill
-TSTP"手法を使用する必要があるでしょう。)

Emacsがテキスト端末で表示されているときは、事はそれほど簡単ではないので、以下で他のさまざまな方法を説明します(とはいえ、それらはPosixシステムだけでキンするシグナルを使用した場合のみ機能します)。

Emacsディストリビューション内のsrc/.gdbinitファイルはSIGINT(Emacsのtext-modeのフレームでのC-g)をGDBに制御を戻さずにEmacsに渡されるようアレンジしています。モダンなシステムでは、以下のコマンドでこれをオーバーライドできます:

   handle SIGINT stop nopass

この'handle'コマンドの後は、SIGINTにより制御がGDBのリターンされるでしょう。Emacsにも同様にC-gでQUITを送りたい場合は、'nopass'を省略してください。シグナルのハンドリングと'handle'コマンドについての詳細は、GDBのマニュアルを参照してください。

'handle SIGINT'が機能しない場合に使えるテクニックは、何らかの文字コードを変数stop_characterに格納する方法です。したがって、

    set stop_character = 29

これはControl-](10進の29)をストップ文字にします。これでControl-]をタイプすれば、即座にストップします。下位プロセスが開始されるまでsetコマンドは使用できないので、上述の'set'コマンドの機会を得るために、Emacsを'start'コマンドで開始してください。

Posixホストでは、以下のようにシェルプロンプトから'kill'コマンドを使用してシグナルを送ることもできます。

   kill -TSTP Emacs-PID

ここでEmacs-PIDはデバッグされているEmacsのプロセスIDです。他に送信するシグナルとして有用なのがSIGUSR1とSIGUSR2です。これらのシグナルの使い方は、ELispマニュアルの"Error
Debugging"を参照してください。

Emacsがテキスト端末で表示されているときは、デバッグセッション用に別の端末があると便利です。これは通常どおりEmacsを開始して、gdbから'attach'コマンドでアタッチして行うことができます。このコマンドは、GDBマニュアルの"Attach"ノードで説明されています。

MS-WindowsではGDB配下でEmacsを実行する前にnew-consoleオプションをセットすることにより、別のコンソールからEmacsを開始できます。

  (gdb) set new-console 1 (gdb) run

これを行なった場合、GDBと対話しているコンソールウィンドウからC-cやC-BREAKをタイプすると、EmacsがGUIかtext-modeフレームで表示されているかに関わらず、Emacsはストップして制御がGDBにリターンされるでしょう。これは、事前にブレークポイントをセットする以外に、MS-Windowsでデバッガが制御を得るための唯一信頼できる代替方法です。

** Examining Lisp object values.

デバッグの生きたプロセスがあり、致命的なエラーに遭遇戦していなければ、GDBコマンド'pr'を使用できます。最初は通常の方法、'p'コマンドで値をプリントしてください。それから引数なしで'pr'とタイプします。これはLispプリンターを使用するサブルーチンを呼び出します。

emacsの値を直接プリントするために、'pp value'を使用することもできます。

Lisp変数のカレント値を確認するためには、'pv value'を使用します。

これらのコマンドは出力をstderrに送ります。stderrがcloseされていたり、あなたには不明な何らかのファイルにリダイレクトされている場合、これらの出力を確認することはできないでしょう。これは特にMS-Windows上でデスクトップショートカットからEmacsが呼び出された場合が該当します。GNU/Linuxではコマンド'redirect-debugging-output'を使用して、stderrをファイルにリダイレクトできます。

注意:
Emacsが深刻なトラブルの渦中、スタックが破壊(たとえばスタックオーバーフローによるSIGSEGVなど)されていたり、'obarray'のようなデータ構造の循環参照や不正構造があると解っている状況で'pr'、'pp'、'pv'を試みるのは、良いアイデアではありません。このような場合、'pr'により呼び出されるEmacsサブルーチンは、元の問題をデバッグするために重要な何らかのデータを上書きしてしまう等、より多くのダメージを与えてしまうかもしれません。

さらに'select'の内部にいる間にEmacsをストップした場合は、'pr'の使用が不可能なシステムもいくつかあります。Emacsがwaitしている間にEmacsをストップすると、これは実際に発生します。このような状況では、'pr'の使用を試みてはなりません。かわりにシステムコールをステップアウトするために、's'を使用してください。その後、Emacsは命令文の間に、'pr'を処理することができるようになるでしょう。

理由が何であれ、'pr'コマンドが使用できない場合は、直前のデータ値のデータ型と値をプリントする'xpr'コマンドを使用できます。

    p it->object xpr

低レベルコマンドを使用して、データ値を分析するかもしれません。直前のデータ値のデータ型のプリントには、'xtype'コマンドを使用します。一度データ型が解れば、その型に対応するコマンドを使用できます。以下はそれらのコマンドです:

    xint xptr xwindow xmarker xoverlay xmiscfree xintfwd xboolfwd xobjfwd
xbufobjfwd xkbobjfwd xbuflocal xbuffer xsymbol xstring xvector xframe
xwinconfig xcompiled xcons xcar xcdr xsubr xprocess xfloat xscrollbar
xchartable xsubchartable xboolvector xhashtable xlist xcoding xcharset
xfontset xfont xbytecode

これらの1つ1つは、特定の型やクラス型を受け入れます(これらの型のいくつかは内部的にのみ存在する型なので、Lispでは不可視です)。

それぞれのx...コマンドは、その内容の残りから得られるものを通じて、値についてのいくつかの情報と、GDB値(続けて$により利用可能)をプリントします。

一般的に内容の残りのほとんどはx...コマンドで順に検証していくことができる、追加のLispオブジェクトでしょう。

生きたプロセスにおいても、これらのx...コマンドはバッファー、ウィンドウ、プロセス、マーカー内の検証に役立ちます。以下はフレームと呼ばれる変数に関連する値をプリントするために、GDBマニュアル"Value
History"ノードで説明されている概念を使用する例です:

  cd src gdb emacs b set_frame_buffer_list r -q

その後、Emacsはブレークポイントに達します:

  (gdb) p frame $1 = 139854428 (gdb) xpr Lisp_Vectorlike PVEC_FRAME $2 =
(struct frame *) 0x8560258 "emacs@localhost" (gdb) p *$ $3 = { size =
1073742931, next = 0x85dfe58, name = 140615219, [...] }

これで'pp'を使用してフレームパラメーターをプリントできます:

  (gdb) pp $->param_alist ((background-mode . light) (display-type . color)
[...])

EmacsのCコードは、lisp.h内で定義されたマクロを多用します。keyboard.cの'add_command_key'の最後の方にある左辺値式(l-value
expression)のアドレスが知りたいとします:

  XVECTOR (this_command_keys)->contents[this_command_key_count++] = key;

XVECTORはマクロなので、Emacsがプリプロセッサーマクロ情報とともにコンパイルされた場合だけそれを知ることができます。オプション'-gdwarf-N'(Nは2以上)と'-g3'を指定した場合、GCCはこの情報を提供します。この場合、GDBは"p
XVECTOR (this_command_keys)"のような式を評価できます。

この情報が利用できない場合は、同じ結果を得るためにGDB内でxvectorコマンドを使用できます。以下は使用方法です:

  (gdb) p this_command_keys $1 = 1078005760 (gdb) xvector $2 = (struct
Lisp_Vector *) 0x411000 0 (gdb) p $->contents[this_command_key_count] $3 =
1077872640 (gdb) p &$ $4 = (int *) 0x411008

以下はマクロとGDBの'define'コマンドに関する例です。'recent_keys'(最後のキーストローク300個を含む)のようなLispベクターが多数存在します。このLispベクターを以下のようにしてプリントできます

  p recent_keys pr

'recent_keys'は'C-h
l'に比べて出力が多く、これは不便かもしれません。わたしたちなら、このベクターの最後の10要素だけをプリントしたいと望むでしょう。'recent_keys'はkeyboard.c内でコマンドにより更新されます

  XVECTOR (recent_keys)->contents[recent_keys_index] = c;

わたしたちはGDBコマンド'xvector-elts'を定義して、以下のように最後のキーストローク10個をプリントします

  xvector-elts recent_keys recent_keys_index 10

ここでxvector-eltsは以下のように定義します:

  define xvector-elts set $i = 0 p $arg0 xvector set $foo = $ while $i < $arg2
p $foo->contents[$arg1-($i++)] pr end document xvector-elts Prints a range
of elements of a Lisp vector.  xvector-elts v n i prints 'i' elements of the
vector 'v' ending at the index 'n'.  end

** Getting Lisp-level backtrace information within GDB

'xbacktrace'コマンドを使用するのがもっとも便利な方法です。これはカレントでアクティブなLisp関数の名前を表示します。

もしこれが機能しない(たとえば'backtrace_list'構造が不正等により)場合は、Cレベルのバックトレースを生成するために、GDBプロンプトで"bt"とタイプして、Ffuncallを呼び出しているスタックフレームを探してください。"up
N"とタイプして、それらのスタックフレームをGDBで1つずつ選択していきます。ここでNは上位フレームに移動するための適切な数字です。そしてFfuncallを呼び出しているフレームごとに以下をタイプします:

   p *args pr

これにより、そのレベルの関数呼び出しにより呼び出されているLisp関数の名前がプリントされます。

argsの残りの要素をプリントすることにより、Lisp関数の引数の値を確認できます。以下は最初の引数をプリントする方法です:

   p args[1] pr

生きたプロセスがない場合は、xtypeと他のx...コマンドを使用できます。便利さは劣りますが、このような情報はxsymbolのようなコマンドで取得します。たとえば、

   p *args xtype

"xtype"が、args[0]をsymbolだと告げた場合は:

   xsymbol

** Debugging Emacs redisplay problems

--enable-checking='glyphs'でEmacsをconfigureした場合は、実行中のEmacsセッションから再表示(redisplay)トレース機能を使用できます。

コマンド"M-x trace-redisplay
RET"は再表示が行うことのトレースを標準エラーストリームに生成します。さまざまな状況下でディスプレイエンジンにより選択されるコードパス(code
path:実際に実行されるコードの道筋)を理解するために、特にある再表示最適化が誤った結果を生成する場合に、非常に役に立ちます(承知のとおり、"M-x
redraw-display
RET"、あるいは"M-x"とタイプするだけでも、Emacsが誤った表示を修正するために再表示最適化がよびだされます)。カーソル点滅機能(cursor
blinking
feature)は定期的な再表示サイクルをトリガーするので、余計なものをトレースから減らすために、'trace-redisplay'を呼び出す前に'blink-cursor-mode'を無効にすることを推奨します。dump-redisplay-history'コマンドを呼び出して、最後のトレースメッセージを30個まで標準エラーにダンプすることもできます。

ディスプレイエンジンが選択するコードパスを見つけるには、トレースメッセージからxdisp.cを探します。

コマンド'dump-glyph-matrix'は、選択されたウィンドウのグリフマトリクス(glyph
matrix)の完全なダンプを標準エラーストリームに生成するのに役立ちます。詳細は関数のドキュメント文字列を参照してください。text-modeフレームで再表示に関する問題をデバッグしている場合は、コマンド'dump-frame-glyph-matrix'が便利なことに気づくかもしれません。

再表示をデバッグするとき有用な他のコマンドには、'dump-glyph-row'と'dump-tool-bar-row'があります。

GDB配下でEmacsを実行している場合は、マトリクスを引数にその関数を呼び出すだけで、任意のグリフマトリクスの内容をプリントできます。たとえば、以下のコマンドは、ウィンドウ(ポインター'w')のカレントマトリクスの内容をプリントします:

  (gdb) p dump_glyph_matrix (w->current_matrix, 2)

(2つ目の引数2はdump_glyph_matrixにグリフを長い形式プリントするよう指定します。)

ディスプレイ関係のEmacsのコードには特別なデバッグ用コードが含まれていますが、通常は無効になっています。--enable-checking='yes,glyphs'でEmacsをconfigureすることにより、これが有効になります。

このようにEmacsをビルドすると、ディスプレイコード処理を検査する多くのassertionが、通常Emacsが行うより多く活性化されます(これらのassertionが何をテストしているかは、'eassert'マクロ呼び出しを確認してください)。失敗を報告するassertionは精査するべきです。

X配下で実行中のEmacsにたいしてディスプレイの問題をデバッグするときは、'ff'コマンドを使用して、待機中のすべての画面表示の更新をflushできます。

src/.gdbinitファイルでは、再表示関連のデータ構造を簡潔でユーザーフレンドリーなフォーマットでダンプするためのコマンドが多数定義されています:

 'ppt' prints value of PT, narrowing, and gap in current buffer.  'pit' dumps
the current display iterator 'it'.  'pwin' dumps the current window 'win'.
'prow' dumps the current glyph_row 'row'.  'pg' dumps the current glyph
'glyph'.  'pgi' dumps the next glyph.  'pgrow' dumps all glyphs in current
glyph_row 'row'.  'pcursor' dumps current output_cursor.

上記のコマンドには関連する型のオブジェクトを引数とする、サフィックス'x'のついたバージョンも存在します。たとえば、'pgrowx'は引数内のすべてのグリフをダンプします。引数の型は'struct
glyph_row'でなければなりません。

再表示はEmacsにより非常に頻繁に行われるので、デバッグ中の問題が(まだ)発生していないのに、再表示のたびに毎回ブレークしてしまうのを避けるため、ブレークポイントを巧妙に配す必要があります。これに関する有用なテクニックを以下に挙げます:

 . Put a breakpoint at 'Fredraw_display' before running Emacs.  Then do
whatever is required to reproduce the bad display, and invoke "M-x
redraw-display".  The debugger will kick in, and you can set or enable
breakpoints in strategic places, knowing that the bad display will be
redrawn from scratch.

 . For debugging incorrect cursor position, a good place to put a breakpoint
is in 'set_cursor_from_row'.  The first time this function is called as part
of 'redraw-display', Emacs is redrawing the minibuffer window, which is
usually not what you want; type "continue" to get to the call you want.  In
general, always make sure 'set_cursor_from_row' is called for the right
window and buffer by examining the value of w->contents: it should be the
buffer whose display you are debugging.

 . 'set_cursor_from_row' is also a good place to look at the contents of a
screen line (a.k.a. "glyph row"), by means of the 'pgrow' GDB command.  Of
course, you need first to make sure the cursor is on the screen line which
you want to investigate.  If you have set a breakpoint in 'Fredraw_display',
as advised above, move cursor to that line before invoking 'redraw-display'.

 . If the problem happens only at some specific buffer position or for some
specific rarely-used character, you can make your breakpoints conditional on
those values.  The display engine maintains the buffer and string position
it is processing in the it->current member; for example, the buffer
character position is in it->current.pos.charpos.  Most redisplay functions
accept a pointer to a 'struct it' object as their argument, so you can make
conditional breakpoints in those functions, like this:

    (gdb) break x_produce_glyphs if it->current.pos.charpos == 1234

   For conditioning on the character being displayed, use it->c or
it->char_to_display.

 . You can also make the breakpoints conditional on what object is being used
for producing glyphs for display.  The it->method member has the value
GET_FROM_BUFFER for displaying buffer contents, GET_FROM_STRING for
displaying a Lisp string (e.g., a 'display' property or an overlay string),
GET_FROM_IMAGE for displaying an image, etc.  See 'enum it_method' in
dispextern.h for the full list of values.

** Following longjmp call.

最新バージョンのglibc(2.4+?)は、GDBの'next'使用によるlongjmp呼び出しの追跡を防ぐため、setjmp/longjmpにたいする値を暗号化して格納します。この保護を無効にするためには、環境変数LD_POINTER_GUARDに0をセットする必要があります。

** Using GDB in Emacs

Emacs内でのGDBによるデバッグには、コマンドラインでのデバッグにたいしていくつかの利点があります(EmacsマニュアルのGDB Graphical
Interfaceノードを参照)。Emacsでのデバッグだけで利用できる機能もいくつかあります:

1) The command gud-print is available on the tool bar (the 'p' icon) and
allows the user to print the s-expression of the variable at point, in the
GUD buffer.

2) Pressing 'p' on a component of a watch expression that is a lisp object
in the speedbar prints its s-expression in the GUD buffer.

3) The STOP button on the tool bar and the Signals->STOP menu-bar menu item
are adjusted so that they send SIGTSTP instead of the usual SIGINT.

4) The command gud-pv has the global binding 'C-x C-a C-v' and prints the
value of the lisp variable at point.

** Debugging what happens while preloading and dumping Emacs

ダンプされていないEmacsで発生する問題なのか確証を得たい場合は、'temacs'をデバッグするのが役立ちます。デバッガ配下で'temacs'を実行するには、"gdb
temacs"とタイプしてから'r -batch -l loadup'で開始します。

ダンプ中に何が起こっているかデバッグする必要がある場合は、かわりに'r -batch -l loadup
dump'で開始します。bootstrapのダンプのデバッグには、"loadup dump"のかわりに"loadup
bootstrap"を使用してください。

この方法によりGDB配下でtemacsの実行に実際に成功した場合は、ダンプされたEmacsの実行を試みないでください。なぜならそれはGDBのブレークポイントがセットされた状態でダンプされているからです。

** If you encounter X protocol errors

Xサーバーは通常、プロトコルエラーを非同期で報告するので、エラーがリターンされる原因の根本よりかなり後にそれらの見つけることになります。

エラー原因についての明快な情報を入手するために、(x-synchronize
t)を評価してみてください。これはEmacsを同期モードにして、それぞれのXlib呼び出しにたいしてリターン前にエラーをチェックします。このモードはかなり低速ですが、エラーが発生したとき、どの呼び出しがエラーを発生させたか正確に確認できるでしょう。

以下のように-xrmオプションとともに呼び出すことにより、同期モードでEmacsを開始できます:

    emacs -xrm "emacs.synchronous: true"

関数'x_error_quitter'内にブレークポイントをセットして、Emacsがストップしたときにその関数内のバックトレースを調べれば、Xプロトコルエラーの原因となったコードを確認できるでしょう。

同期モードでEmacsが実行中のときは発生しないXプロトコル関連のエラーもいくつかあります。これらのバグを追跡するために、以下の手順を提案します:

  - Run Emacs under a debugger and put a breakpoint inside the primitive
function which, when called from Lisp, triggers the X protocol errors.  For
example, if the errors happen when you delete a frame, put a breakpoint
inside 'Fdelete_frame'.

  - When the breakpoint breaks, step through the code, looking for calls to X
functions (the ones whose names begin with "X" or "Xt" or "Xm").

  - Insert calls to 'XSync' before and after each call to the X functions,
like this:

       XSync (f->output_data.x->display_info->display, 0);

    where 'f' is the pointer to the 'struct frame' of the selected frame,
normally available via XFRAME (selected_frame).  (Most functions which call
X already have some variable that holds the pointer to the frame, perhaps
called 'f' or 'sf', so you shouldn't need to compute it.)

    If your debugger can call functions in the program being debugged, you
should be able to issue the calls to 'XSync' without recompiling Emacs.  For
example, with GDB, just type:

       call XSync (f->output_data.x->display_info->display, 0)

    before and immediately after the suspect X calls.  If your debugger does not
support this, you will need to add these pairs of calls in the source and
rebuild Emacs.

    Either way, systematically step through the code and issue these calls until
you find the first X function called by Emacs after which a call to 'XSync'
winds up in the function 'x_error_quitter'.  The first X function call for
which this happens is the one that generated the X protocol error.

  - You should now look around this offending X call and try to figure out
what is wrong with it.

** If Emacs causes errors or memory leaks in your X server

xmon(ftp://ftp.x.org/contrib/devel_tools/から入手可能)のようなツールで、EmacsとXサーバー間のトラフィックをトレースできます。

xmonはXプロトコルエラー発生時にEmacsが何を送信したのか正確に知るために使用できます。EmacsがXサーバーのメモリー使用を増大させている場合は、Xサーバー内にEmacsがどんなアイテム(windows、graphical
contexts、pixmaps)を作成、または削除したかをxmonを使用して確認できます。もし終始一貫して削除より作成が多い場合は、そのアイテムの型とそのアイテムが作成されるとき行っていたアクティビティが、デバッグ開始のヒントになり得ます。

** If the symptom of the bug is that Emacs fails to respond

Don't assume Emacs is 'hung'--it may instead be in an infinite loop.  To
find out which, make the problem happen under GDB and stop Emacs once it is
not responding.  (If Emacs is using X Windows directly, you can stop Emacs
by typing C-z at the GDB job.  On MS-Windows, run Emacs as usual, and then
attach GDB to it -- that will usually interrupt whatever Emacs is doing and
let you perform the steps described below.)

Then try stepping with 'step'.  If Emacs is hung, the 'step' command won't
return.  If it is looping, 'step' will return.

If this shows Emacs is hung in a system call, stop it again and examine the
arguments of the call.  If you report the bug, it is very important to state
exactly where in the source the system call is, and what the arguments are.

If Emacs is in an infinite loop, try to determine where the loop starts and
ends.  The easiest way to do this is to use the GDB command 'finish'.  Each
time you use it, Emacs resumes execution until it exits one stack frame.
Keep typing 'finish' until it doesn't return--that means the infinite loop
is in the stack frame which you just tried to finish.

Stop Emacs again, and use 'finish' repeatedly again until you get back to
that frame.  Then use 'next' to step through that frame.  By stepping, you
will see where the loop starts and ends.  Also, examine the data being used
in the loop and try to determine why the loop does not exit when it should.

On GNU and Unix systems, you can also trying sending Emacs SIGUSR2, which,
if 'debug-on-event' has its default value, will cause Emacs to attempt to
break it out of its current loop and into the Lisp debugger.  (See the node
"Debugging" in the ELisp manual for the details about the Lisp debugger.)
This feature is useful when a C-level debugger is not conveniently
available.

** If certain operations in Emacs are slower than they used to be, here is
some advice for how to find out why.

Stop Emacs repeatedly during the slow operation, and make a backtrace each
time.  Compare the backtraces looking for a pattern--a specific function
that shows up more often than you'd expect.

If you don't see a pattern in the C backtraces, get some Lisp backtrace
information by typing "xbacktrace" or by looking at Ffuncall frames (see
above), and again look for a pattern.

When using X, you can stop Emacs at any time by typing C-z at GDB.  When not
using X, you can do this with C-g.  On non-Unix platforms, such as MS-DOS,
you might need to press C-BREAK instead.

** If GDB does not run and your debuggers can't load Emacs.

On some systems, no debugger can load Emacs with a symbol table, perhaps
because they all have fixed limits on the number of symbols and Emacs
exceeds the limits.  Here is a method that can be used in such an
extremity.  Do

    nm -n temacs > nmout strip temacs adb temacs 0xd:i 0xe:i 14:i 17:i :r -l
loadup (or whatever)

It is necessary to refer to the file 'nmout' to convert numeric addresses
into symbols and vice versa.

It is useful to be running under a window system.  Then, if Emacs becomes
hopelessly wedged, you can create another window to do kill -9 in.  kill
-ILL is often useful too, since that may make Emacs dump core or return to
adb.

** Debugging incorrect screen updating on a text terminal.

To debug Emacs problems that update the screen wrong, it is useful to have a
record of what input you typed and what Emacs sent to the screen.  To make
these records, do

(open-dribble-file "~/.dribble")  (open-termscript "~/.termscript")

The dribble file contains all characters read by Emacs from the terminal,
and the termscript file contains all characters it sent to the terminal.
The use of the directory '~/' prevents interference with any other user.

If you have irreproducible display problems, put those two expressions in
your ~/.emacs file.  When the problem happens, exit the Emacs that you were
running, kill it, and rename the two files.  Then you can start another
Emacs without clobbering those files, and use it to examine them.

An easy way to see if too much text is being redrawn on a terminal is to
evaluate '(setq inverse-video t)' before you try the operation you think
will cause too much redrawing.  This doesn't refresh the screen, so only
newly drawn text is in inverse video.

** Debugging LessTif

If you encounter bugs whereby Emacs built with LessTif grabs all mouse and
keyboard events, or LessTif menus behave weirdly, it might be helpful to set
the 'DEBUGSOURCES' and 'DEBUG_FILE' environment variables, so that one can
see what LessTif was doing at this point.  For instance

  export DEBUGSOURCES="RowColumn.c:MenuShell.c:MenuUtil.c" export
DEBUG_FILE=/usr/tmp/LESSTIF_TRACE emacs &

causes LessTif to print traces from the three named source files to a file
in '/usr/tmp' (that file can get pretty large).  The above should be typed
at the shell prompt before invoking Emacs, as shown by the last line above.

Running GDB from another terminal could also help with such problems.  You
can arrange for GDB to run on one machine, with the Emacs display appearing
on another.  Then, when the bug happens, you can go back to the machine
where you started GDB and use the debugger from there.

** Debugging problems which happen in GC

The array 'last_marked' (defined on alloc.c) can be used to display up to
500 last objects marked by the garbage collection process.  Whenever the
garbage collector marks a Lisp object, it records the pointer to that object
in the 'last_marked' array, which is maintained as a circular buffer.  The
variable 'last_marked_index' holds the index into the 'last_marked' array
one place beyond where the pointer to the very last marked object is stored.

The single most important goal in debugging GC problems is to find the Lisp
data structure that got corrupted.  This is not easy since GC changes the
tag bits and relocates strings which make it hard to look at Lisp objects
with commands such as 'pr'.  It is sometimes necessary to convert
Lisp_Object variables into pointers to C struct's manually.

Use the 'last_marked' array and the source to reconstruct the sequence that
objects were marked.  In general, you need to correlate the values recorded
in the 'last_marked' array with the corresponding stack frames in the
backtrace, beginning with the innermost frame.  Some subroutines of
'mark_object' are invoked recursively, others loop over portions of the data
structure and mark them as they go.  By looking at the code of those
routines and comparing the frames in the backtrace with the values in
'last_marked', you will be able to find connections between the values in
'last_marked'.  E.g., when GC finds a cons cell, it recursively marks its
car and its cdr.  Similar things happen with properties of symbols, elements
of vectors, etc.  Use these connections to reconstruct the data structure
that was being marked, paying special attention to the strings and names of
symbols that you encounter: these strings and symbol names can be used to
grep the sources to find out what high-level symbols and global variables
are involved in the crash.

Once you discover the corrupted Lisp object or data structure, grep the
sources for its uses and try to figure out what could cause the corruption.
If looking at the sources doesn't help, you could try setting a watchpoint
on the corrupted data, and see what code modifies it in some invalid way.
(Obviously, this technique is only useful for data that is modified only
very rarely.)

It is also useful to look at the corrupted object or data structure in a
fresh Emacs session and compare its contents with a session that you are
debugging.

** Debugging problems with non-ASCII characters

If you experience problems which seem to be related to non-ASCII characters,
such as \201 characters appearing in the buffer or in your files, set the
variable byte-debug-flag to t.  This causes Emacs to do some extra checks,
such as look for broken relations between byte and character positions in
buffers and strings; the resulting diagnostics might pinpoint the cause of
the problem.

** Debugging the TTY (non-windowed) version

The most convenient method of debugging the character-terminal display is to
do that on a window system such as X.  Begin by starting an xterm window,
then type these commands inside that window:

  $ tty $ echo $TERM

Let's say these commands print "/dev/ttyp4" and "xterm", respectively.

Now start Emacs (the normal, windowed-display session, i.e. without the
'-nw' option), and invoke "M-x gdb RET emacs RET" from there.  Now type
these commands at GDB's prompt:

  (gdb) set args -nw -t /dev/ttyp4 (gdb) set environment TERM xterm (gdb) run

The debugged Emacs should now start in no-window mode with its display
directed to the xterm window you opened above.

Similar arrangement is possible on a character terminal by using the
'screen' package.

On MS-Windows, you can start Emacs in its own separate console by setting
the new-console option before running Emacs under GDB:

  (gdb) set new-console 1 (gdb) run

** Running Emacs built with malloc debugging packages

If Emacs exhibits bugs that seem to be related to use of memory allocated
off the heap, it might be useful to link Emacs with a special debugging
library, such as Electric Fence (a.k.a. efence) or GNU Checker, which helps
find such problems.

Emacs compiled with such packages might not run without some hacking,
because Emacs replaces the system's memory allocation functions with its own
versions, and because the dumping process might be incompatible with the way
these packages use to track allocated memory.  Here are some of the changes
you might find necessary:

  - Edit configure, to set system_malloc and CANNOT_DUMP to "yes".

  - Configure with a different --prefix= option.  If you use GCC, version
2.7.2 is preferred, as some malloc debugging packages work a lot better with
it than with 2.95 or later versions.

  - Type "make" then "make -k install".

  - If required, invoke the package-specific command to prepare src/temacs for
execution.

  - cd ..; src/temacs

(Note that this runs 'temacs' instead of the usual 'emacs' executable.  This
avoids problems with dumping Emacs mentioned above.)

Some malloc debugging libraries might print lots of false alarms for
bitfields used by Emacs in some data structures.  If you want to get rid of
the false alarms, you will have to hack the definitions of these data
structures on the respective headers to remove the ':N' bitfield definitions
(which will cause each such field to use a full int).

** How to recover buffer contents from an Emacs core dump file

The file etc/emacs-buffer.gdb defines a set of GDB commands for recovering
the contents of Emacs buffers from a core dump file.  You might also find
those commands useful for displaying the list of buffers in human-readable
format from within the debugger.


This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.


Local variables:
mode: org
paragraph-separate: "[ 	\f]*$"
end:
