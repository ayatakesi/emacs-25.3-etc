GNU Emacsのデバッグ

Copyright (C) 1985, 2000-2017 Free Software Foundation, Inc.  See the end of
the file for license conditions.

** Preliminaries

このセクションは、あなたがすでにdebug情報つきEmacsのビルドや、GDBの設定と開始、GDBによる簡単なデバッグテクニックに親しんでいる場合はスキップできます。

*** Configuring Emacs for debugging

デバッグを簡単にするには、特別なオプションでEmacsをconfigureしてビルドするのが最善です。以下はわたしたちが推奨するconfigure時のオプションです(これらのオプションは、--prefixのようなあなたが必要とするかもしれない他のオプションに追加します)。

  CFLAGS='-O0 -g3' ./configure --enable-checking='yes,glyphs'
--enable-check-lisp-object-type

CFLAGSの値は重要です。なぜなら最適化されたコードのデバッグはとても困難だからです。(最適化されたコードでのみ問題が発生する場合は、最適化を有効にする必要があるかもしれません。このような場合は-O2のかわりにまず-Ogの使用を試みてください。-Ogはある種のコードのデバッグを極めて困難にするいくつかの最適化を無効にします。)

GCCのモダンなバージョンはコンパイラースイッチに-g3を使用するだけで利用できる、より精緻なdebug情報をサポートします。-g3に加えて-gdwarf-4を、それが失敗するようなら-gdwarf-3を試してみてください。これは最適化されたコードをデバッグする必要がある場合、とても重要になります。これに関する追加情報は以下の"analyze
failed assertionsの検索"にあります。

2つの--enable-*スイッチはオプションです。これらはGDBによるデバッグに影響を与えませんが、デバッグしている問題をより早くcatchするかもしれない追加コードをassertion
violation形式でコンパイルします。--enable-checkingオプションは表示に関する問題をデバッグするのに有用な追加機能も有効にします。詳細は、以下の"Emacsの再表示に関する問題のデバッグ"を参照してください。

デバッグ用のEmacsをインストールする必要はありません。'src'ディレクトリーに作成されるバイナリーをデバッグできます。

*** Configuring GDB

GDBでEmacをデバッグするときは、Emacs実行形式が作成されたディレクトリー(Emacsソースツリー内の'src'ディレクトリー)から直接GDBを開始するべきです。このディレクトリーには、Emacsをデバッグするためのさまざまなユーザー定義コマンドを定義する、.gdbinitファイルがあります(これらのコマンドは以下の"Lispオブジェクトの値の調査"および"Emacsの再表示に関する問題のデバッグ"で説明されています)。

カレントバッファーでEmacsのCソースファイルのどれか1つをvisitしているときに、Emacsから"M-x
gdb"コマンド(以下参照)によりデバッガーを開始すると、'src'ディレクトリー内で自動的にGDBが開始されます。

GDBのいくつかのバージョンでは、デフォルトではGDBを呼び出したディレクトリー内の.gdbinitファイルを自動的にロードしません。このようなバージョンのGDBでは、GDBを開始したとき以下のような警告を目にするかもしれません:

  warning: File ".../src/.gdbinit" auto-loading has been declined by your
`auto-load safe-path' set to "$debugdir:$datadir/auto-load".

これを修正するには~/.gdbinitファイルに以下の行を追加するのが、もっとも簡単な方法です:

  add-auto-load-safe-path /path/to/emacs/src/.gdbinit

この問題を克服するための方法は他にもいくつかあり、それらはすべてGDBユーザーマニュアルの"Auto-loading safe
path"ノードで説明されています。それらでも効果がない場合は、無条件でGDB initファイルをロードするために、GDBプロンプトで"source
/path/to/.gdbinit RET"とタイプしてください。

*** Use the Emacs GDB UI front-end

わたしたちはEmacsが提供するGDB用のGUIフロントエンドの使用を推奨します。
We recommend using the GUI front-end for GDB provided by Emacs.
このフロントエンドは、"M-x gdb RET"とタイプしてGDBを開始できます。
With it, you can start GDB by typing
このコマンドはデバッグするデフォルトのバイナリーのファイル名を提案します。この提案されるデフォルトが、デバッグしたいEmacsバイナリーと異なる場合は、必要に応じてファイル名を変更してください。かわりに、すでに実行中のEmacsプロセスにデバッガをアタッチしたい場合は、ミニバッファーに表示されているGDBコマンドにそれを告げるように変更します:

   gdb -i=mi -p PID

ここでPIDはPosixホストでは'top'や'ps'のようなシステムユーティリティーで、MS-WindowsではTask
Managerで表示される、実行中EmacsのPID数値です。

一度デバッガが起動すると"M-x gdb-many-windows
RET"とタイプすることにより、GDBUIが提供する追加のウィンドウがオープンします(メニューバーの"Gud->GDB-MI->Display
Other
Windows"をクリックしてもオープンできる)。この時点では、オープンしたウィンドウが水平スクロールせずに内容を表示するのに十分なスペースがあるよう、フレームを十分に大きく(またはフルスクリーン)しておいてください。

ウィンドウ構成は後でコマンド"M-x gdb-restore-windows RET"、またはメニューバーの"Display Other
Windows"を選択解除すればリストアできます。

*** Setting initial breakpoints

Emacsを実行させる前に、デバッガしたいコードにブレークポイントをセットすべきときです。ブレークポイントをセットすればEmacsはそこでストップして、GDBに制御を渡せます。デバッグしたいコードが、ある稀な状況下で実行されるコードであったり、特定のEmacsコマンドを手動で呼び出したときだけ実行されるコードの場合は、そこにブレークポイントをセットしてEmacsを実行すれば、そのコマンドの呼び出し、またはそれらの稀な状況を再現することにより、ブレークポイントがトリガーされます。

それほど幸運でなく、問題となっているコードが非常に頻繁に実行される場合は、バグのある振る舞いが発生する条件までブレークポイントがトリガーされないようにする方法を見つける必要があります。これにたいする唯一の処方はありません。あなたはより創造的になるとともに、何が適切か判断するためにコードを学ぶ必要があるでしょう。以下に、これにたいする有用なトリックをいくつか挙げます:

  . Make your breakpoint conditional on certain buffer or string position.
For example:

      (gdb) break foo.c:1234 if PT >= 9876

  . Set a break point in some rarely called function, then create the
conditions for the bug, call that rare function, and when GDB gets control,
set the breakpoint in the buggy code, knowing that it will now be called
when the bug happens.

  . If the bug manifests itself as an error message, set a breakpoint in
Fsignal, and when it breaks, look at the backtrace to see what triggers the
error.

他の追加テクニックは、以下の"デバッガに制御を渡す"で説明されています。

これでデバッグセッションを開始する準備ができました。

新たなEmacsセッションを開始した場合は、*gud-emacs*バッファー内で"run"とタイプした後にコマンドライン引数(例
"-Q")を続けてからRETを押下します。

実行中のEmacsにデバッガをアタッチした場合は、*gud-emacs*バッファー内で"continue"とタイプしてからRETを押下します。

Lispオブジェクトをデバッガする間、多くの変数に出会うことでしょう。これらは整数値(configure時に"--enable-check-lisp-object-type"オプションを使用した場合は構造体)なので解釈が困難であり、とりわけ長いリストで表現されている場合は困難です。これらをLisp形式で表示するために、'pp'コマンドを使用できます。このコマンドは出力を標準エラーストリーム(GNU/Linuxシステムでは"M-x
redirect-debugging-output"を使用してファイルにリダイレクトできます)に表示します。これはデスクトップアイコンから呼び出された実行中のEmacsにGDBをアタッチした場合に、出力を確認できなかったり、出力がどこか不明な場所(デスクトップ環境のドキュメントをチェックしてください)に切り捨てられる危険があることを意味します。

Lispオブジェクトの表示に関する追加情報は、以下の"Lispオブジェクトの値の調査"で見つけることができます。

このドキュメントの残りの部分は、Emacsのデバッグにおいて特に有用なテクニックを説明します。初めてEmacsをデバッグしようとするときは全体をありのまま目を通しておいて、必要なときに特定の問題を参照するよう、わたしたちは提案します。

Good luck!

** When you are trying to analyze failed assertions or backtraces, it is
essential to compile Emacs with flags suitable for debugging.  With GCC 4.8
or later, you can invoke 'make' with CFLAGS="-Og -g3".  With older GCC or
non-GCC compilers, you can use CFLAGS="-O0 -g3".  With GCC and higher
optimization levels such as -O2, the -fno-omit-frame-pointer and
-fno-crossjumping options are often essential.  The latter prevents GCC from
using the same abort call for all assertions in a given function, rendering
the stack backtrace useless for identifying the specific failed assertion.
Some versions of GCC support recent versions of the DWARF standard for
debugging info, but default to older versions; for example, they could
support -gdwarf-4 compiler option (for DWARF v4), but default to version 2
of the DWARF standard.  For best results in debugging abilities, find out
the highest version of DWARF your GCC can support, and use the corresponding
-gdwarf-N switch instead of just -g (you will still need -g3, as in
"-gdwarf-4 -g3").

** It is a good idea to run Emacs under GDB (or some other suitable
debugger) *all the time*.  Then, when Emacs crashes, you will be able to
debug the live process, not just a core dump.  (This is especially important
on systems which don't support core files, and instead print just the
registers and some stack addresses.)

** If Emacs hangs, or seems to be stuck in some infinite loop, typing "kill
-TSTP PID", where PID is the Emacs process ID, will cause GDB to kick in,
provided that you run under GDB.

** Getting control to the debugger

デバッガにEmacsをロードした後で、それを実行する前に効果的な場所にブレークポイントをセットすることは、必要なときにデバッガに確実に制御をリターンさせるもっとも効果的な方法です。

'Fsignal'はブレークポイントを配すのに、とても役に立つ場所です。すべてのLispエラーはここを通過します。Lispデバッガを起動させるエラーだけに関心がある場合は、'maybe_call_debugger'にブレークポイントを置くのが役に立つでしょう。

デバッガに制御を渡す他のテクニックとして、稀に使用されるいくつかの関数にブレークポイントを配す方法があります。そのような便利な関数の1つがFredraw_displayで、これは"M-x
redraw-display RET"でインタラクティブに呼び出すことができます。

任意のタイミングでデバッガにリターンするために、保証された方法があるのも便利です。これはXを使用しているときは簡単です。GDBで対話中のウィンドウでC-zをタイプすれば、普通のプログラムと同様にEmacsもストップします。(これは実行中のEmacsにアタッチされたGDBでは機能しません。この場合はEmacsを起動したシェルのウィンドウでC-zとタイプするか、以下で説明している"kill
-TSTP"手法を使用する必要があるでしょう。)

Emacsがテキスト端末で表示されているときは、事はそれほど簡単ではないので、以下で他のさまざまな方法を説明します(とはいえ、それらはPosixシステムだけでキンするシグナルを使用した場合のみ機能します)。

Emacsディストリビューション内のsrc/.gdbinitファイルはSIGINT(Emacsのtext-modeのフレームでのC-g)をGDBに制御を戻さずにEmacsに渡されるようアレンジしています。モダンなシステムでは、以下のコマンドでこれをオーバーライドできます:

   handle SIGINT stop nopass

この'handle'コマンドの後は、SIGINTにより制御がGDBのリターンされるでしょう。Emacsにも同様にC-gでQUITを送りたい場合は、'nopass'を省略してください。シグナルのハンドリングと'handle'コマンドについての詳細は、GDBのマニュアルを参照してください。

'handle SIGINT'が機能しない場合に使えるテクニックは、何らかの文字コードを変数stop_characterに格納する方法です。したがって、

    set stop_character = 29

これはControl-](10進の29)をストップ文字にします。これでControl-]をタイプすれば、即座にストップします。下位プロセスが開始されるまでsetコマンドは使用できないので、上述の'set'コマンドの機会を得るために、Emacsを'start'コマンドで開始してください。

Posixホストでは、以下のようにシェルプロンプトから'kill'コマンドを使用してシグナルを送ることもできます。

   kill -TSTP Emacs-PID

ここでEmacs-PIDはデバッグされているEmacsのプロセスIDです。他に送信するシグナルとして有用なのがSIGUSR1とSIGUSR2です。これらのシグナルの使い方は、ELispマニュアルの"Error
Debugging"を参照してください。

Emacsがテキスト端末で表示されているときは、デバッグセッション用に別の端末があると便利です。これは通常どおりEmacsを開始して、gdbから'attach'コマンドでアタッチして行うことができます。このコマンドは、GDBマニュアルの"Attach"ノードで説明されています。

MS-WindowsではGDB配下でEmacsを実行する前にnew-consoleオプションをセットすることにより、別のコンソールからEmacsを開始できます。

  (gdb) set new-console 1 (gdb) run

これを行なった場合、GDBと対話しているコンソールウィンドウからC-cやC-BREAKをタイプすると、EmacsがGUIかtext-modeフレームで表示されているかに関わらず、Emacsはストップして制御がGDBにリターンされるでしょう。これは、事前にブレークポイントをセットする以外に、MS-Windowsでデバッガが制御を得るための唯一信頼できる代替方法です。

** Examining Lisp object values.

When you have a live process to debug, and it has not encountered a fatal
error, you can use the GDB command 'pr'.  First print the value in the
ordinary way, with the 'p' command.  Then type 'pr' with no arguments.  This
calls a subroutine which uses the Lisp printer.

You can also use 'pp value' to print the emacs value directly.

To see the current value of a Lisp Variable, use 'pv variable'.

These commands send their output to stderr; if that is closed or redirected
to some file you don't know, you won't see their output.  This is
particularly so for Emacs invoked on MS-Windows from the desktop shortcut.
On GNU/Linux, you can use the command 'redirect-debugging-output' to
redirect stderr to a file.

Note: It is not a good idea to try 'pr', 'pp', or 'pv' if you know that
Emacs is in deep trouble: its stack smashed (e.g., if it encountered SIGSEGV
due to stack overflow), or crucial data structures, such as 'obarray',
corrupted, etc.  In such cases, the Emacs subroutine called by 'pr' might
make more damage, like overwrite some data that is important for debugging
the original problem.

Also, on some systems it is impossible to use 'pr' if you stopped Emacs
while it was inside 'select'.  This is in fact what happens if you stop
Emacs while it is waiting.  In such a situation, don't try to use 'pr'.
Instead, use 's' to step out of the system call.  Then Emacs will be between
instructions and capable of handling 'pr'.

If you can't use 'pr' command, for whatever reason, you can use the 'xpr'
command to print out the data type and value of the last data value, For
example:

    p it->object xpr

You may also analyze data values using lower-level commands.  Use the
'xtype' command to print out the data type of the last data value.  Once you
know the data type, use the command that corresponds to that type.  Here are
these commands:

    xint xptr xwindow xmarker xoverlay xmiscfree xintfwd xboolfwd xobjfwd
xbufobjfwd xkbobjfwd xbuflocal xbuffer xsymbol xstring xvector xframe
xwinconfig xcompiled xcons xcar xcdr xsubr xprocess xfloat xscrollbar
xchartable xsubchartable xboolvector xhashtable xlist xcoding xcharset
xfontset xfont xbytecode

Each one of them applies to a certain type or class of types.  (Some of
these types are not visible in Lisp, because they exist only internally.)

Each x... command prints some information about the value, and produces a
GDB value (subsequently available in $) through which you can get at the
rest of the contents.

In general, most of the rest of the contents will be additional Lisp objects
which you can examine in turn with the x... commands.

Even with a live process, these x...  commands are useful for examining the
fields in a buffer, window, process, frame or marker.  Here's an example
using concepts explained in the node "Value History" of the GDB manual to
print values associated with the variable called frame.  First, use these
commands:

  cd src gdb emacs b set_frame_buffer_list r -q

Then Emacs hits the breakpoint:

  (gdb) p frame $1 = 139854428 (gdb) xpr Lisp_Vectorlike PVEC_FRAME $2 =
(struct frame *) 0x8560258 "emacs@localhost" (gdb) p *$ $3 = { size =
1073742931, next = 0x85dfe58, name = 140615219, [...] }

Now we can use 'pp' to print the frame parameters:

  (gdb) pp $->param_alist ((background-mode . light) (display-type . color)
[...])

The Emacs C code heavily uses macros defined in lisp.h.  So suppose we want
the address of the l-value expression near the bottom of 'add_command_key'
from keyboard.c:

  XVECTOR (this_command_keys)->contents[this_command_key_count++] = key;

XVECTOR is a macro, so GDB only knows about it if Emacs has been compiled
with preprocessor macro information.  GCC provides this if you specify the
options '-gdwarf-N' (where N is 2 or higher) and '-g3'.  In this case, GDB
can evaluate expressions like "p XVECTOR (this_command_keys)".

When this information isn't available, you can use the xvector command in
GDB to get the same result.  Here is how:

  (gdb) p this_command_keys $1 = 1078005760 (gdb) xvector $2 = (struct
Lisp_Vector *) 0x411000 0 (gdb) p $->contents[this_command_key_count] $3 =
1077872640 (gdb) p &$ $4 = (int *) 0x411008

Here's a related example of macros and the GDB 'define' command.  There are
many Lisp vectors such as 'recent_keys', which contains the last 300
keystrokes.  We can print this Lisp vector

  p recent_keys pr

But this may be inconvenient, since 'recent_keys' is much more verbose than
'C-h l'.  We might want to print only the last 10 elements of this vector.
'recent_keys' is updated in keyboard.c by the command

  XVECTOR (recent_keys)->contents[recent_keys_index] = c;

So we define a GDB command 'xvector-elts', so the last 10 keystrokes are
printed by

  xvector-elts recent_keys recent_keys_index 10

where you can define xvector-elts as follows:

  define xvector-elts set $i = 0 p $arg0 xvector set $foo = $ while $i < $arg2
p $foo->contents[$arg1-($i++)] pr end document xvector-elts Prints a range
of elements of a Lisp vector.  xvector-elts v n i prints 'i' elements of the
vector 'v' ending at the index 'n'.  end

** Getting Lisp-level backtrace information within GDB

The most convenient way is to use the 'xbacktrace' command.  This shows the
names of the Lisp functions that are currently active.

If that doesn't work (e.g., because the 'backtrace_list' structure is
corrupted), type "bt" at the GDB prompt, to produce the C-level backtrace,
and look for stack frames that call Ffuncall.  Select them one by one in
GDB, by typing "up N", where N is the appropriate number of frames to go up,
and in each frame that calls Ffuncall type this:

   p *args pr

This will print the name of the Lisp function called by that level of
function calling.

By printing the remaining elements of args, you can see the argument
values.  Here's how to print the first argument:

   p args[1] pr

If you do not have a live process, you can use xtype and the other x...
commands such as xsymbol to get such information, albeit less conveniently.
For example:

   p *args xtype

and, assuming that "xtype" says that args[0] is a symbol:

   xsymbol

** Debugging Emacs redisplay problems

If you configured Emacs with --enable-checking='glyphs', you can use
redisplay tracing facilities from a running Emacs session.

The command "M-x trace-redisplay RET" will produce a trace of what redisplay
does on the standard error stream.  This is very useful for understanding
the code paths taken by the display engine under various conditions,
especially if some redisplay optimizations produce wrong results.  (You know
that redisplay optimizations might be involved if "M-x redraw-display RET",
or even just typing "M-x", causes Emacs to correct the bad display.)  Since
the cursor blinking feature triggers periodic redisplay cycles, we recommend
disabling 'blink-cursor-mode' before invoking 'trace-redisplay', so that you
have less clutter in the trace.  You can also have up to 30 last trace
messages dumped to standard error by invoking the 'dump-redisplay-history'
command.

To find the code paths which were taken by the display engine, search
xdisp.c for the trace messages you see.

The command 'dump-glyph-matrix' is useful for producing on standard error
stream a full dump of the selected window's glyph matrix.  See the
function's doc string for more details.  If you are debugging redisplay
issues in text-mode frames, you may find the command
'dump-frame-glyph-matrix' useful.

Other commands useful for debugging redisplay are 'dump-glyph-row' and
'dump-tool-bar-row'.

If you run Emacs under GDB, you can print the contents of any glyph matrix
by just calling that function with the matrix as its argument.  For example,
the following command will print the contents of the current matrix of the
window whose pointer is in 'w':

  (gdb) p dump_glyph_matrix (w->current_matrix, 2)

(The second argument 2 tells dump_glyph_matrix to print the glyphs in a long
form.)

The Emacs display code includes special debugging code, but it is normally
disabled.  Configuring Emacs with --enable-checking='yes,glyphs' enables it.

Building Emacs like that activates many assertions which scrutinize display
code operation more than Emacs does normally.  (To see the code which tests
these assertions, look for calls to the 'eassert' macros.)  Any assertion
that is reported to fail should be investigated.

When you debug display problems running emacs under X, you can use the 'ff'
command to flush all pending display updates to the screen.

The src/.gdbinit file defines many useful commands for dumping redisplay
related data structures in a terse and user-friendly format:

 'ppt' prints value of PT, narrowing, and gap in current buffer.  'pit' dumps
the current display iterator 'it'.  'pwin' dumps the current window 'win'.
'prow' dumps the current glyph_row 'row'.  'pg' dumps the current glyph
'glyph'.  'pgi' dumps the next glyph.  'pgrow' dumps all glyphs in current
glyph_row 'row'.  'pcursor' dumps current output_cursor.

The above commands also exist in a version with an 'x' suffix which takes an
object of the relevant type as argument.  For example, 'pgrowx' dumps all
glyphs in its argument, which must be of type 'struct glyph_row'.

Since redisplay is performed by Emacs very frequently, you need to place
your breakpoints cleverly to avoid hitting them all the time, when the issue
you are debugging did not (yet) happen.  Here are some useful techniques for
that:

 . Put a breakpoint at 'Fredraw_display' before running Emacs.  Then do
whatever is required to reproduce the bad display, and invoke "M-x
redraw-display".  The debugger will kick in, and you can set or enable
breakpoints in strategic places, knowing that the bad display will be
redrawn from scratch.

 . For debugging incorrect cursor position, a good place to put a breakpoint
is in 'set_cursor_from_row'.  The first time this function is called as part
of 'redraw-display', Emacs is redrawing the minibuffer window, which is
usually not what you want; type "continue" to get to the call you want.  In
general, always make sure 'set_cursor_from_row' is called for the right
window and buffer by examining the value of w->contents: it should be the
buffer whose display you are debugging.

 . 'set_cursor_from_row' is also a good place to look at the contents of a
screen line (a.k.a. "glyph row"), by means of the 'pgrow' GDB command.  Of
course, you need first to make sure the cursor is on the screen line which
you want to investigate.  If you have set a breakpoint in 'Fredraw_display',
as advised above, move cursor to that line before invoking 'redraw-display'.

 . If the problem happens only at some specific buffer position or for some
specific rarely-used character, you can make your breakpoints conditional on
those values.  The display engine maintains the buffer and string position
it is processing in the it->current member; for example, the buffer
character position is in it->current.pos.charpos.  Most redisplay functions
accept a pointer to a 'struct it' object as their argument, so you can make
conditional breakpoints in those functions, like this:

    (gdb) break x_produce_glyphs if it->current.pos.charpos == 1234

   For conditioning on the character being displayed, use it->c or
it->char_to_display.

 . You can also make the breakpoints conditional on what object is being used
for producing glyphs for display.  The it->method member has the value
GET_FROM_BUFFER for displaying buffer contents, GET_FROM_STRING for
displaying a Lisp string (e.g., a 'display' property or an overlay string),
GET_FROM_IMAGE for displaying an image, etc.  See 'enum it_method' in
dispextern.h for the full list of values.

** Following longjmp call.

Recent versions of glibc (2.4+?) encrypt stored values for setjmp/longjmp
which prevents GDB from being able to follow a longjmp call using 'next'.
To disable this protection you need to set the environment variable
LD_POINTER_GUARD to 0.

** Using GDB in Emacs

Debugging with GDB in Emacs offers some advantages over the command line
(See the GDB Graphical Interface node of the Emacs manual).  There are also
some features available just for debugging Emacs:

1) The command gud-print is available on the tool bar (the 'p' icon) and
allows the user to print the s-expression of the variable at point, in the
GUD buffer.

2) Pressing 'p' on a component of a watch expression that is a lisp object
in the speedbar prints its s-expression in the GUD buffer.

3) The STOP button on the tool bar and the Signals->STOP menu-bar menu item
are adjusted so that they send SIGTSTP instead of the usual SIGINT.

4) The command gud-pv has the global binding 'C-x C-a C-v' and prints the
value of the lisp variable at point.

** Debugging what happens while preloading and dumping Emacs

Debugging 'temacs' is useful when you want to establish whether a problem
happens in an undumped Emacs.  To run 'temacs' under a debugger, type "gdb
temacs", then start it with 'r -batch -l loadup'.

If you need to debug what happens during dumping, start it with 'r -batch -l
loadup dump' instead.  For debugging the bootstrap dumping, use "loadup
bootstrap" instead of "loadup dump".

If temacs actually succeeds when running under GDB in this way, do not try
to run the dumped Emacs, because it was dumped with the GDB breakpoints in
it.

** If you encounter X protocol errors

The X server normally reports protocol errors asynchronously, so you find
out about them long after the primitive which caused the error has returned.

To get clear information about the cause of an error, try evaluating
(x-synchronize t).  That puts Emacs into synchronous mode, where each Xlib
call checks for errors before it returns.  This mode is much slower, but
when you get an error, you will see exactly which call really caused the
error.

You can start Emacs in a synchronous mode by invoking it with the -xrm
option, like this:

    emacs -xrm "emacs.synchronous: true"

Setting a breakpoint in the function 'x_error_quitter' and looking at the
backtrace when Emacs stops inside that function will show what code causes
the X protocol errors.

Some bugs related to the X protocol disappear when Emacs runs in a
synchronous mode.  To track down those bugs, we suggest the following
procedure:

  - Run Emacs under a debugger and put a breakpoint inside the primitive
function which, when called from Lisp, triggers the X protocol errors.  For
example, if the errors happen when you delete a frame, put a breakpoint
inside 'Fdelete_frame'.

  - When the breakpoint breaks, step through the code, looking for calls to X
functions (the ones whose names begin with "X" or "Xt" or "Xm").

  - Insert calls to 'XSync' before and after each call to the X functions,
like this:

       XSync (f->output_data.x->display_info->display, 0);

    where 'f' is the pointer to the 'struct frame' of the selected frame,
normally available via XFRAME (selected_frame).  (Most functions which call
X already have some variable that holds the pointer to the frame, perhaps
called 'f' or 'sf', so you shouldn't need to compute it.)

    If your debugger can call functions in the program being debugged, you
should be able to issue the calls to 'XSync' without recompiling Emacs.  For
example, with GDB, just type:

       call XSync (f->output_data.x->display_info->display, 0)

    before and immediately after the suspect X calls.  If your debugger does not
support this, you will need to add these pairs of calls in the source and
rebuild Emacs.

    Either way, systematically step through the code and issue these calls until
you find the first X function called by Emacs after which a call to 'XSync'
winds up in the function 'x_error_quitter'.  The first X function call for
which this happens is the one that generated the X protocol error.

  - You should now look around this offending X call and try to figure out
what is wrong with it.

** If Emacs causes errors or memory leaks in your X server

You can trace the traffic between Emacs and your X server with a tool like
xmon, available at ftp://ftp.x.org/contrib/devel_tools/.

Xmon can be used to see exactly what Emacs sends when X protocol errors
happen.  If Emacs causes the X server memory usage to increase you can use
xmon to see what items Emacs creates in the server (windows, graphical
contexts, pixmaps) and what items Emacs delete.  If there are consistently
more creations than deletions, the type of item and the activity you do when
the items get created can give a hint where to start debugging.

** If the symptom of the bug is that Emacs fails to respond

Don't assume Emacs is 'hung'--it may instead be in an infinite loop.  To
find out which, make the problem happen under GDB and stop Emacs once it is
not responding.  (If Emacs is using X Windows directly, you can stop Emacs
by typing C-z at the GDB job.  On MS-Windows, run Emacs as usual, and then
attach GDB to it -- that will usually interrupt whatever Emacs is doing and
let you perform the steps described below.)

Then try stepping with 'step'.  If Emacs is hung, the 'step' command won't
return.  If it is looping, 'step' will return.

If this shows Emacs is hung in a system call, stop it again and examine the
arguments of the call.  If you report the bug, it is very important to state
exactly where in the source the system call is, and what the arguments are.

If Emacs is in an infinite loop, try to determine where the loop starts and
ends.  The easiest way to do this is to use the GDB command 'finish'.  Each
time you use it, Emacs resumes execution until it exits one stack frame.
Keep typing 'finish' until it doesn't return--that means the infinite loop
is in the stack frame which you just tried to finish.

Stop Emacs again, and use 'finish' repeatedly again until you get back to
that frame.  Then use 'next' to step through that frame.  By stepping, you
will see where the loop starts and ends.  Also, examine the data being used
in the loop and try to determine why the loop does not exit when it should.

On GNU and Unix systems, you can also trying sending Emacs SIGUSR2, which,
if 'debug-on-event' has its default value, will cause Emacs to attempt to
break it out of its current loop and into the Lisp debugger.  (See the node
"Debugging" in the ELisp manual for the details about the Lisp debugger.)
This feature is useful when a C-level debugger is not conveniently
available.

** If certain operations in Emacs are slower than they used to be, here is
some advice for how to find out why.

Stop Emacs repeatedly during the slow operation, and make a backtrace each
time.  Compare the backtraces looking for a pattern--a specific function
that shows up more often than you'd expect.

If you don't see a pattern in the C backtraces, get some Lisp backtrace
information by typing "xbacktrace" or by looking at Ffuncall frames (see
above), and again look for a pattern.

When using X, you can stop Emacs at any time by typing C-z at GDB.  When not
using X, you can do this with C-g.  On non-Unix platforms, such as MS-DOS,
you might need to press C-BREAK instead.

** If GDB does not run and your debuggers can't load Emacs.

On some systems, no debugger can load Emacs with a symbol table, perhaps
because they all have fixed limits on the number of symbols and Emacs
exceeds the limits.  Here is a method that can be used in such an
extremity.  Do

    nm -n temacs > nmout strip temacs adb temacs 0xd:i 0xe:i 14:i 17:i :r -l
loadup (or whatever)

It is necessary to refer to the file 'nmout' to convert numeric addresses
into symbols and vice versa.

It is useful to be running under a window system.  Then, if Emacs becomes
hopelessly wedged, you can create another window to do kill -9 in.  kill
-ILL is often useful too, since that may make Emacs dump core or return to
adb.

** Debugging incorrect screen updating on a text terminal.

To debug Emacs problems that update the screen wrong, it is useful to have a
record of what input you typed and what Emacs sent to the screen.  To make
these records, do

(open-dribble-file "~/.dribble")  (open-termscript "~/.termscript")

The dribble file contains all characters read by Emacs from the terminal,
and the termscript file contains all characters it sent to the terminal.
The use of the directory '~/' prevents interference with any other user.

If you have irreproducible display problems, put those two expressions in
your ~/.emacs file.  When the problem happens, exit the Emacs that you were
running, kill it, and rename the two files.  Then you can start another
Emacs without clobbering those files, and use it to examine them.

An easy way to see if too much text is being redrawn on a terminal is to
evaluate '(setq inverse-video t)' before you try the operation you think
will cause too much redrawing.  This doesn't refresh the screen, so only
newly drawn text is in inverse video.

** Debugging LessTif

If you encounter bugs whereby Emacs built with LessTif grabs all mouse and
keyboard events, or LessTif menus behave weirdly, it might be helpful to set
the 'DEBUGSOURCES' and 'DEBUG_FILE' environment variables, so that one can
see what LessTif was doing at this point.  For instance

  export DEBUGSOURCES="RowColumn.c:MenuShell.c:MenuUtil.c" export
DEBUG_FILE=/usr/tmp/LESSTIF_TRACE emacs &

causes LessTif to print traces from the three named source files to a file
in '/usr/tmp' (that file can get pretty large).  The above should be typed
at the shell prompt before invoking Emacs, as shown by the last line above.

Running GDB from another terminal could also help with such problems.  You
can arrange for GDB to run on one machine, with the Emacs display appearing
on another.  Then, when the bug happens, you can go back to the machine
where you started GDB and use the debugger from there.

** Debugging problems which happen in GC

The array 'last_marked' (defined on alloc.c) can be used to display up to
500 last objects marked by the garbage collection process.  Whenever the
garbage collector marks a Lisp object, it records the pointer to that object
in the 'last_marked' array, which is maintained as a circular buffer.  The
variable 'last_marked_index' holds the index into the 'last_marked' array
one place beyond where the pointer to the very last marked object is stored.

The single most important goal in debugging GC problems is to find the Lisp
data structure that got corrupted.  This is not easy since GC changes the
tag bits and relocates strings which make it hard to look at Lisp objects
with commands such as 'pr'.  It is sometimes necessary to convert
Lisp_Object variables into pointers to C struct's manually.

Use the 'last_marked' array and the source to reconstruct the sequence that
objects were marked.  In general, you need to correlate the values recorded
in the 'last_marked' array with the corresponding stack frames in the
backtrace, beginning with the innermost frame.  Some subroutines of
'mark_object' are invoked recursively, others loop over portions of the data
structure and mark them as they go.  By looking at the code of those
routines and comparing the frames in the backtrace with the values in
'last_marked', you will be able to find connections between the values in
'last_marked'.  E.g., when GC finds a cons cell, it recursively marks its
car and its cdr.  Similar things happen with properties of symbols, elements
of vectors, etc.  Use these connections to reconstruct the data structure
that was being marked, paying special attention to the strings and names of
symbols that you encounter: these strings and symbol names can be used to
grep the sources to find out what high-level symbols and global variables
are involved in the crash.

Once you discover the corrupted Lisp object or data structure, grep the
sources for its uses and try to figure out what could cause the corruption.
If looking at the sources doesn't help, you could try setting a watchpoint
on the corrupted data, and see what code modifies it in some invalid way.
(Obviously, this technique is only useful for data that is modified only
very rarely.)

It is also useful to look at the corrupted object or data structure in a
fresh Emacs session and compare its contents with a session that you are
debugging.

** Debugging problems with non-ASCII characters

If you experience problems which seem to be related to non-ASCII characters,
such as \201 characters appearing in the buffer or in your files, set the
variable byte-debug-flag to t.  This causes Emacs to do some extra checks,
such as look for broken relations between byte and character positions in
buffers and strings; the resulting diagnostics might pinpoint the cause of
the problem.

** Debugging the TTY (non-windowed) version

The most convenient method of debugging the character-terminal display is to
do that on a window system such as X.  Begin by starting an xterm window,
then type these commands inside that window:

  $ tty $ echo $TERM

Let's say these commands print "/dev/ttyp4" and "xterm", respectively.

Now start Emacs (the normal, windowed-display session, i.e. without the
'-nw' option), and invoke "M-x gdb RET emacs RET" from there.  Now type
these commands at GDB's prompt:

  (gdb) set args -nw -t /dev/ttyp4 (gdb) set environment TERM xterm (gdb) run

The debugged Emacs should now start in no-window mode with its display
directed to the xterm window you opened above.

Similar arrangement is possible on a character terminal by using the
'screen' package.

On MS-Windows, you can start Emacs in its own separate console by setting
the new-console option before running Emacs under GDB:

  (gdb) set new-console 1 (gdb) run

** Running Emacs built with malloc debugging packages

If Emacs exhibits bugs that seem to be related to use of memory allocated
off the heap, it might be useful to link Emacs with a special debugging
library, such as Electric Fence (a.k.a. efence) or GNU Checker, which helps
find such problems.

Emacs compiled with such packages might not run without some hacking,
because Emacs replaces the system's memory allocation functions with its own
versions, and because the dumping process might be incompatible with the way
these packages use to track allocated memory.  Here are some of the changes
you might find necessary:

  - Edit configure, to set system_malloc and CANNOT_DUMP to "yes".

  - Configure with a different --prefix= option.  If you use GCC, version
2.7.2 is preferred, as some malloc debugging packages work a lot better with
it than with 2.95 or later versions.

  - Type "make" then "make -k install".

  - If required, invoke the package-specific command to prepare src/temacs for
execution.

  - cd ..; src/temacs

(Note that this runs 'temacs' instead of the usual 'emacs' executable.  This
avoids problems with dumping Emacs mentioned above.)

Some malloc debugging libraries might print lots of false alarms for
bitfields used by Emacs in some data structures.  If you want to get rid of
the false alarms, you will have to hack the definitions of these data
structures on the respective headers to remove the ':N' bitfield definitions
(which will cause each such field to use a full int).

** How to recover buffer contents from an Emacs core dump file

The file etc/emacs-buffer.gdb defines a set of GDB commands for recovering
the contents of Emacs buffers from a core dump file.  You might also find
those commands useful for displaying the list of buffers in human-readable
format from within the debugger.


This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.


Local variables: mode: outline paragraph-separate: "[ 	]*$" end:
